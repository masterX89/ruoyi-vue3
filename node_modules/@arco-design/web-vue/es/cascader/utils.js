var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { isArray, isString, isNumber } from "../_utils/is.js";
const getOptionsWithTotalLeaves = (options) => {
  const _options = [];
  for (const item of options) {
    const data = __spreadValues({}, item);
    if (data.children) {
      data.children = getOptionsWithTotalLeaves(data.children);
      data.totalLeafOptions = data.children.reduce((pre, item2) => {
        if (isNumber(item2.totalLeafOptions)) {
          return pre + item2.totalLeafOptions;
        }
        return pre + (item2.isLeaf || !item2.children ? 1 : 0);
      }, 0);
    }
    _options.push(data);
  }
  return _options;
};
const getOptionInfos = (options, {
  optionMap,
  leafOptionMap,
  leafOptionValueMap,
  leafOptionSet,
  totalLevel: innerLevel,
  checkStrictly,
  enabledLazyLoad,
  lazyLoadOptions
}) => {
  const _options = getOptionsWithTotalLeaves(options);
  let totalLevel = 0;
  const travelOptions = (options2, parent, level) => {
    var _a;
    const parentPath = (_a = parent == null ? void 0 : parent.path) != null ? _a : [];
    totalLevel = Math.max(totalLevel, level != null ? level : 1);
    return options2.map((item, index) => {
      var _a2;
      const data = __spreadProps(__spreadValues({}, item), {
        label: (_a2 = item.label) != null ? _a2 : String(item.value),
        disabled: Boolean(item.disabled),
        level: parentPath.length,
        index,
        parent
      });
      const path = parentPath.concat(data);
      const key = path.map((item2) => item2.value).join("-");
      data.path = path;
      data.key = key;
      if (item.children) {
        data.isLeaf = false;
        data.children = travelOptions(item.children, data, (level != null ? level : 1) + 1);
      } else if (enabledLazyLoad && !data.isLeaf) {
        data.isLeaf = false;
        if (lazyLoadOptions[key]) {
          data.children = travelOptions(lazyLoadOptions[key], data, (level != null ? level : 1) + 1);
        }
      } else {
        data.isLeaf = true;
      }
      optionMap.set(data.key, data);
      if (data.isLeaf || checkStrictly.value) {
        leafOptionSet.add(data);
        leafOptionMap.set(data.key, data);
        if (!leafOptionValueMap.has(data.value)) {
          leafOptionValueMap.set(data.value, data);
        }
      }
      return data;
    });
  };
  const result = travelOptions(_options);
  innerLevel.value = totalLevel;
  return result;
};
const getCheckedStatus = (option, computedKeys) => {
  var _a;
  let checked = false;
  let indeterminate = false;
  if (option.isLeaf) {
    if (computedKeys.includes(option.key)) {
      checked = true;
    }
  } else {
    const reg = new RegExp(`^${option.key}(-|$)`);
    const checkedLeafOptionNumber = computedKeys.reduce((pre, key) => {
      if (reg.test(key)) {
        return pre + 1;
      }
      return pre;
    }, 0);
    if (checkedLeafOptionNumber > 0 && checkedLeafOptionNumber >= ((_a = option.totalLeafOptions) != null ? _a : 1)) {
      checked = true;
    } else if (checkedLeafOptionNumber > 0) {
      indeterminate = true;
    }
  }
  return {
    checked,
    indeterminate
  };
};
const getLeafOptionKeys = (option) => {
  const keys = [];
  if (option.isLeaf) {
    keys.push(option.key);
  } else if (option.children) {
    for (const item of option.children) {
      keys.push(...getLeafOptionKeys(item));
    }
  }
  return keys;
};
const getKeysFromValue = (value, {
  pathMode,
  leafOptionMap,
  leafOptionValueMap
}) => {
  const keys = [];
  if (!pathMode) {
    if (isArray(value)) {
      value.forEach((item) => {
        if (isString(item) || isNumber(item)) {
          const option = leafOptionValueMap.get(item);
          if (option) {
            keys.push(option.key);
          }
        }
      });
    } else if (isString(value) || isNumber(value)) {
      const option = leafOptionValueMap.get(value);
      if (option) {
        keys.push(option.key);
      }
    }
  } else if (isArray(value) && value.length > 0) {
    if (isString(value[0]) || isNumber(value[0])) {
      const key = value.join("-");
      if (leafOptionMap.has(key)) {
        keys.push(key);
      }
    } else {
      value.forEach((item) => {
        if (isArray(item)) {
          const key = item.join("-");
          if (leafOptionMap.has(key)) {
            keys.push(key);
          }
        }
      });
    }
  }
  return keys;
};
export { getCheckedStatus, getKeysFromValue, getLeafOptionKeys, getOptionInfos };
