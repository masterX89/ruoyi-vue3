import { defineComponent, inject, toRefs, ref, reactive, watch, computed, provide, resolveComponent, openBlock, createBlock, mergeProps, withCtx, createVNode } from "vue";
import { getOptionInfos, getKeysFromValue, getLeafOptionKeys } from "./utils.js";
import Trigger from "../trigger/index.js";
import SelectView from "../_components/select-view/select-view.js";
import CascaderPanel from "./cascader-panel.js";
import CascaderSearchPanel from "./cascader-search-panel.js";
import { isArray } from "../_utils/is.js";
import { useSelectedPath } from "./hooks/use-selected-path.js";
import { getKeyDownHandler, CODE } from "../_utils/keyboard.js";
import { cascaderInjectionKey } from "./context.js";
import { configProviderInjectionKey } from "../config-provider/context.js";
import _export_sfc from "../_virtual/plugin-vue_export-helper";
const _sfc_main = defineComponent({
  name: "Cascader",
  components: {
    Trigger,
    SelectView,
    CascaderPanel,
    CascaderSearchPanel
  },
  inheritAttrs: false,
  props: {
    pathMode: {
      type: Boolean,
      default: false
    },
    multiple: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: [String, Number, Array]
    },
    defaultValue: {
      type: [String, Number, Array],
      default: (props) => props.multiple ? [] : props.mode === "value" ? "" : void 0
    },
    options: {
      type: Array,
      default: () => []
    },
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: () => {
        var _a, _b;
        return (_b = (_a = inject(configProviderInjectionKey, void 0)) == null ? void 0 : _a.size) != null ? _b : "medium";
      }
    },
    allowSearch: {
      type: Boolean,
      default: (props) => Boolean(props.multiple)
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    inputValue: {
      type: String,
      default: void 0
    },
    defaultInputValue: {
      type: String,
      default: ""
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    expandTrigger: {
      type: String,
      default: "click"
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    placeholder: String,
    filterOption: {
      type: Function
    },
    popupContainer: {
      type: [String, Object]
    },
    maxTagCount: {
      type: Number,
      default: 0
    },
    formatLabel: {
      type: Function
    },
    triggerProps: {
      type: Object
    },
    checkStrictly: {
      type: Boolean,
      default: false
    },
    loadMore: {
      type: Function
    },
    loading: {
      type: Boolean,
      default: false
    },
    onChange: {
      type: [Function, Array]
    },
    onInputValueChange: {
      type: [Function, Array]
    },
    onPopupVisibleChange: {
      type: [Function, Array]
    },
    onClear: { type: [Function, Array] },
    onSearch: {
      type: [Function, Array]
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "inputValueChange",
    "clear",
    "search",
    "popupVisibleChange",
    "focus",
    "blur"
  ],
  setup(props, { emit }) {
    const { options, checkStrictly, loadMore } = toRefs(props);
    const _value = ref(props.defaultValue);
    const _inputValue = ref(props.defaultInputValue);
    const _popupVisible = ref(props.defaultPopupVisible);
    const optionInfos = ref([]);
    const totalLevel = ref(1);
    const optionMap = new Map();
    const leafOptionMap = new Map();
    const leafOptionValueMap = new Map();
    const leafOptionSet = new Set();
    const lazyLoadOptions = reactive({});
    const addLazyLoadOptions = (children, key) => {
      lazyLoadOptions[key] = children;
    };
    watch([options, lazyLoadOptions], ([_options, _lazyLoadOptions]) => {
      optionMap.clear();
      leafOptionMap.clear();
      leafOptionValueMap.clear();
      leafOptionSet.clear();
      optionInfos.value = getOptionInfos(props.options, {
        enabledLazyLoad: Boolean(props.loadMore),
        lazyLoadOptions,
        optionMap,
        leafOptionSet,
        leafOptionMap,
        leafOptionValueMap,
        totalLevel,
        checkStrictly
      });
    }, {
      immediate: true
    });
    const computedKeys = computed(() => {
      var _a;
      return getKeysFromValue((_a = props.modelValue) != null ? _a : _value.value, {
        pathMode: props.pathMode,
        leafOptionMap,
        leafOptionValueMap
      });
    });
    const computedInputValue = computed(() => {
      var _a;
      return (_a = props.inputValue) != null ? _a : _inputValue.value;
    });
    const computedPopupVisible = computed(() => {
      var _a;
      return (_a = props.popupVisible) != null ? _a : _popupVisible.value;
    });
    const filteredLeafOptions = computed(() => Array.from(leafOptionSet).filter((item) => {
      var _a, _b, _c, _d;
      return (_d = (_a = props.filterOption) == null ? void 0 : _a.call(props, computedInputValue.value, item)) != null ? _d : (_c = item.label) == null ? void 0 : _c.toLocaleLowerCase().includes((_b = computedInputValue.value) == null ? void 0 : _b.toLocaleLowerCase());
    }));
    const updateValue = (options2) => {
      let value;
      if (!options2) {
        if (!props.pathMode) {
          value = "";
        }
        setSelectedPath();
        setActiveKey();
      } else if (isArray(options2)) {
        value = options2.map((item) => {
          if (!props.pathMode) {
            return item.value;
          }
          return item.path.map((item2) => item2.value);
        });
      } else if (!props.pathMode) {
        value = options2.value;
      } else {
        value = options2.path.map((item) => item.value);
      }
      _value.value = value;
      emit("update:modelValue", value);
      emit("change", value);
    };
    const handlePopupVisibleChange = (visible) => {
      if (computedPopupVisible.value !== visible) {
        _popupVisible.value = visible;
        emit("popupVisibleChange", visible);
      }
    };
    const handleRemove = (key) => {
      if (props.multiple) {
        const option = leafOptionMap.get(key);
        if (option) {
          selectMultiple(option, false);
        }
      }
    };
    const selectSingle = (option) => {
      updateValue(option);
      handlePopupVisibleChange(false);
    };
    const selectMultiple = (option, checked) => {
      const leafOptionKeys = props.checkStrictly ? [option.key] : getLeafOptionKeys(option);
      const newKeys = checked ? computedKeys.value.concat(leafOptionKeys.filter((item) => !computedKeys.value.includes(item))) : computedKeys.value.filter((item) => !leafOptionKeys.includes(item));
      updateValue(newKeys.map((key) => leafOptionMap.get(key)));
      handleInputValueChange("", "optionChecked");
    };
    const handleClickOption = (option, checked) => {
      if (props.multiple) {
        selectMultiple(option, checked != null ? checked : true);
      } else {
        selectSingle(option);
      }
    };
    const getOptionLabel = (option) => {
      return option.path.map((item) => item.label).join(" / ");
    };
    const handleInputValueChange = (value, reason) => {
      if (value !== computedInputValue.value) {
        if (reason === "manual" && !computedPopupVisible.value) {
          _popupVisible.value = true;
          emit("popupVisibleChange", true);
        }
        _inputValue.value = value;
        emit("inputValueChange", value);
        if (props.allowSearch) {
          emit("search", value);
        }
      }
    };
    watch(computedPopupVisible, (value) => {
      if (value) {
        if (computedKeys.value.length > 0 && !activeKey.value) {
          const lastKey = computedKeys.value[computedKeys.value.length - 1];
          const option = leafOptionMap.get(lastKey);
          if (option) {
            setSelectedPath(option.key);
            setActiveKey(option.key);
          }
        }
      } else {
        if (computedKeys.value.length === 0) {
          setSelectedPath();
          setActiveKey();
        }
        handleInputValueChange("", "optionListHide");
      }
    });
    const handleClear = (e) => {
      e.stopPropagation();
      if (props.multiple) {
        const newValue = computedKeys.value.reduce((pre, key) => {
          const option = leafOptionMap.get(key);
          if (option == null ? void 0 : option.disabled) {
            pre.push(option);
          }
          return pre;
        }, []);
        updateValue(newValue);
      } else {
        updateValue();
      }
      handleInputValueChange("", "manual");
      emit("clear");
    };
    const showSearchPanel = computed(() => props.allowSearch && computedInputValue.value.length > 0);
    const handleFocus = (e) => {
      emit("focus", e);
    };
    const handleBlur = (e) => {
      emit("blur", e);
    };
    const {
      activeKey,
      activeOption,
      selectedPath,
      displayColumns,
      setActiveKey,
      setSelectedPath,
      getNextActiveNode
    } = useSelectedPath(optionInfos, {
      optionMap,
      filteredLeafOptions,
      showSearchPanel
    });
    provide(cascaderInjectionKey, reactive({
      onClickOption: handleClickOption,
      setActiveKey,
      setSelectedPath,
      loadMore,
      addLazyLoadOptions
    }));
    const handleKeyDown = getKeyDownHandler(new Map([
      [
        CODE.ENTER,
        (ev) => {
          if (computedPopupVisible.value) {
            if (activeOption.value && (activeOption.value.isLeaf || props.checkStrictly)) {
              handleClickOption(activeOption.value);
            }
          } else {
            handlePopupVisibleChange(true);
          }
        }
      ],
      [
        CODE.ESC,
        (ev) => {
          handlePopupVisibleChange(false);
        }
      ],
      [
        CODE.ARROW_DOWN,
        (ev) => {
          ev.preventDefault();
          const activeNode = getNextActiveNode("next");
          setActiveKey(activeNode == null ? void 0 : activeNode.key);
        }
      ],
      [
        CODE.ARROW_UP,
        (ev) => {
          ev.preventDefault();
          const activeNode = getNextActiveNode("preview");
          setActiveKey(activeNode == null ? void 0 : activeNode.key);
        }
      ],
      [
        CODE.ARROW_RIGHT,
        (ev) => {
          var _a, _b;
          ev.preventDefault();
          if ((_a = activeOption.value) == null ? void 0 : _a.children) {
            setSelectedPath(activeOption.value.key);
            setActiveKey((_b = activeOption.value.children[0]) == null ? void 0 : _b.key);
          }
        }
      ],
      [
        CODE.ARROW_LEFT,
        (ev) => {
          var _a;
          ev.preventDefault();
          if ((_a = activeOption.value) == null ? void 0 : _a.parent) {
            setSelectedPath(activeOption.value.parent.key);
            setActiveKey(activeOption.value.parent.key);
          }
        }
      ]
    ]));
    const selectViewValue = computed(() => {
      var _a, _b, _c, _d;
      if (props.multiple) {
        const result = [];
        for (const key of computedKeys.value) {
          const option2 = leafOptionMap.get(key);
          if (option2) {
            const value = {
              value: key,
              label: (_b = (_a = props.formatLabel) == null ? void 0 : _a.call(props, option2.path)) != null ? _b : getOptionLabel(option2),
              closable: !option2.disabled,
              tagProps: option2.tagProps
            };
            result.push(value);
          }
        }
        return result;
      }
      const option = leafOptionMap.get(computedKeys.value[0]);
      if (!option) {
        return void 0;
      }
      return {
        value: option.key,
        label: (_d = (_c = props.formatLabel) == null ? void 0 : _c.call(props, option.path)) != null ? _d : getOptionLabel(option),
        closable: !(option == null ? void 0 : option.disabled),
        tagProps: option.tagProps
      };
    });
    return {
      optionInfos,
      computedKeys,
      filteredLeafOptions,
      selectedPath,
      activeKey,
      displayColumns,
      computedInputValue,
      computedPopupVisible,
      handleClear,
      selectViewValue,
      handleInputValueChange,
      showSearchPanel,
      handlePopupVisibleChange,
      handleFocus,
      handleBlur,
      handleRemove,
      handleKeyDown,
      totalLevel
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_select_view = resolveComponent("select-view");
  const _component_cascader_search_panel = resolveComponent("cascader-search-panel");
  const _component_cascader_panel = resolveComponent("cascader-panel");
  const _component_trigger = resolveComponent("trigger");
  return openBlock(), createBlock(_component_trigger, mergeProps(_ctx.triggerProps, {
    trigger: "click",
    "popup-visible": _ctx.computedPopupVisible,
    position: "bl",
    disabled: _ctx.disabled,
    "popup-offset": 4,
    "auto-fit-popup-width": _ctx.showSearchPanel,
    "popup-container": _ctx.popupContainer,
    "prevent-focus": true,
    "click-to-close": !_ctx.allowSearch,
    onPopupVisibleChange: _ctx.handlePopupVisibleChange
  }), {
    content: withCtx(() => [
      _ctx.showSearchPanel ? (openBlock(), createBlock(_component_cascader_search_panel, {
        key: 0,
        options: _ctx.filteredLeafOptions,
        "active-key": _ctx.activeKey,
        "computed-keys": _ctx.computedKeys,
        multiple: _ctx.multiple,
        loading: _ctx.loading
      }, null, 8, ["options", "active-key", "computed-keys", "multiple", "loading"])) : (openBlock(), createBlock(_component_cascader_panel, {
        key: 1,
        "display-columns": _ctx.displayColumns,
        "selected-path": _ctx.selectedPath,
        "active-key": _ctx.activeKey,
        "computed-keys": _ctx.computedKeys,
        multiple: _ctx.multiple,
        "expand-trigger": _ctx.expandTrigger,
        "total-level": _ctx.totalLevel,
        "check-strictly": _ctx.checkStrictly,
        loading: _ctx.loading
      }, null, 8, ["display-columns", "selected-path", "active-key", "computed-keys", "multiple", "expand-trigger", "total-level", "check-strictly", "loading"]))
    ]),
    default: withCtx(() => [
      createVNode(_component_select_view, mergeProps({
        "model-value": _ctx.selectViewValue,
        "input-value": _ctx.computedInputValue,
        disabled: _ctx.disabled,
        error: _ctx.error,
        multiple: _ctx.multiple,
        "allow-clear": _ctx.allowClear,
        "allow-search": _ctx.allowSearch,
        size: _ctx.size,
        opened: _ctx.computedPopupVisible,
        placeholder: _ctx.placeholder,
        loading: _ctx.loading,
        "max-tag-count": _ctx.maxTagCount
      }, _ctx.$attrs, {
        onInputValueChange: _ctx.handleInputValueChange,
        onClear: _ctx.handleClear,
        onFocus: _ctx.handleFocus,
        onBlur: _ctx.handleBlur,
        onRemove: _ctx.handleRemove,
        onKeydown: _ctx.handleKeyDown
      }), null, 16, ["model-value", "input-value", "disabled", "error", "multiple", "allow-clear", "allow-search", "size", "opened", "placeholder", "loading", "max-tag-count", "onInputValueChange", "onClear", "onFocus", "onBlur", "onRemove", "onKeydown"])
    ]),
    _: 1
  }, 16, ["popup-visible", "disabled", "auto-fit-popup-width", "popup-container", "click-to-close", "onPopupVisibleChange"]);
}
var _Cascader = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _Cascader as default };
