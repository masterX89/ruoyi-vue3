var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
import { toRefs, ref, watchEffect, watch, computed } from "vue";
import { isUndefined, isArray, isObject } from "../../_utils/is.js";
function useSelectedState(props) {
  const { defaultValue, modelValue, key2TreeNode, multiple, treeCheckable } = toRefs(props);
  function normalizeValue(value) {
    if (isUndefined(value))
      return void 0;
    if ((multiple == null ? void 0 : multiple.value) || (treeCheckable == null ? void 0 : treeCheckable.value))
      return !isArray(value) ? [value] : value;
    return isArray(value) ? value.slice(0, 1) : [value];
  }
  function getKeys(value) {
    if (!value)
      return void 0;
    const keys = value.map((item) => isObject(item) ? item.value : item).filter((item) => !isUndefined(item) && item !== "");
    return keys;
  }
  function getLabelValues(value, originValue) {
    if (!value) {
      return void 0;
    }
    const originValueMap = new Map();
    originValue == null ? void 0 : originValue.forEach((item) => {
      originValueMap.set(item.value, item);
    });
    value = value.filter((item) => !isUndefined(item) && item !== "");
    if (!value.length) {
      return void 0;
    }
    return value.map((item) => {
      var _a, _b, _c;
      let res = isObject(item) ? __spreadValues({}, item) : { value: item, label: void 0 };
      const node = key2TreeNode.value[res.value];
      res.label = (_b = (_a = res.label) != null ? _a : node == null ? void 0 : node.title) != null ? _b : res.value;
      if (originValueMap && originValueMap.has(res.value)) {
        res = __spreadValues(__spreadValues({}, res), originValueMap.get(res.value));
      }
      res.label = (_c = res.label) != null ? _c : res.value;
      return res;
    });
  }
  const computedModelValueKeys = ref();
  const computedModelValue = ref();
  watchEffect(() => {
    const normalizeModelValue = normalizeValue(modelValue.value);
    const modelValueKeys = getKeys(normalizeModelValue);
    computedModelValueKeys.value = modelValueKeys;
    computedModelValue.value = normalizeModelValue && modelValueKeys && getLabelValues(modelValueKeys, getLabelValues(normalizeModelValue));
  });
  const normalizeDefaultValue = normalizeValue(defaultValue.value);
  const defaultKeys = getKeys(normalizeDefaultValue);
  const defaultLabelValues = getLabelValues(defaultKeys || [], getLabelValues(normalizeDefaultValue || []));
  const localValueKeys = ref(defaultKeys || []);
  const localValue = ref(defaultLabelValues);
  watch(localValueKeys, () => {
    localValue.value = getLabelValues(localValueKeys.value, defaultLabelValues);
  });
  watch([computedModelValueKeys, computedModelValue], ([valueKeys, value]) => {
    localValueKeys.value = valueKeys;
    localValue.value = value;
  });
  const selectedKeys = computed(() => computedModelValueKeys.value || localValueKeys.value);
  const selectedValue = computed(() => computedModelValue.value || localValue.value);
  return {
    selectedKeys,
    selectedValue,
    setLocalSelectedKeys(keys) {
      localValueKeys.value = keys;
    }
  };
}
export { useSelectedState as default };
