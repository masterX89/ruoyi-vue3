var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { defineComponent, inject, toRefs, reactive, ref, computed, watch, resolveComponent, openBlock, createBlock, mergeProps, withCtx, createVNode, renderSlot, normalizeProps } from "vue";
import { getDateValue, dayjs, getNow, isValueChange } from "../_utils/date.js";
import { getPrefixCls } from "../_utils/global-config.js";
import useState from "../_hooks/use-state.js";
import usePickerState from "./hooks/use-picker-state.js";
import DateInput from "../_components/picker/input.js";
import Trigger from "../trigger/index.js";
import { getFormattedValue, isValidInputValue } from "../time-picker/utils/index.js";
import PickerPanel from "./picker-panel.js";
import pick from "../_utils/pick.js";
import useFormat from "./hooks/use-format.js";
import { isFunction } from "../_utils/is.js";
import IconCalendar from "../icon/icon-calendar/index.js";
import useIsDisabledDate from "./hooks/use-is-disabled-date.js";
import useMergeState from "../_hooks/use-merge-state.js";
import useDatePickerTransform from "./hooks/use-provide-datepicker-transform.js";
import useHeaderValue from "./hooks/use-header-value.js";
import { omit } from "../_utils/omit.js";
import useTimePickerValue from "./hooks/use-time-picker-value.js";
import { mergeValueWithTime } from "./utils/index.js";
import { configProviderInjectionKey } from "../config-provider/context.js";
import _export_sfc from "../_virtual/plugin-vue_export-helper";
const _sfc_main = defineComponent({
  name: "Picker",
  components: {
    DateInput,
    Trigger,
    PickerPanel,
    IconCalendar
  },
  inheritAttrs: false,
  props: {
    locale: {
      type: Object
    },
    hideTrigger: {
      type: Boolean
    },
    allowClear: {
      type: Boolean,
      default: true
    },
    readonly: {
      type: Boolean
    },
    error: {
      type: Boolean
    },
    size: {
      type: String,
      default: () => {
        var _a, _b;
        return (_b = (_a = inject(configProviderInjectionKey, void 0)) == null ? void 0 : _a.size) != null ? _b : "medium";
      }
    },
    shortcuts: {
      type: Array,
      default: () => []
    },
    shortcutsPosition: {
      type: String,
      default: "bottom"
    },
    position: {
      type: String,
      default: "bl"
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    triggerProps: {
      type: Object
    },
    unmountOnClose: {
      type: Boolean
    },
    placeholder: {
      type: String
    },
    disabled: {
      type: Boolean
    },
    disabledDate: {
      type: Function
    },
    disabledTime: {
      type: Function
    },
    pickerValue: {
      type: [Object, String, Number]
    },
    defaultPickerValue: {
      type: [Object, String, Number]
    },
    popupContainer: {
      type: [String, Object]
    },
    mode: {
      type: String,
      default: "date"
    },
    format: {
      type: [String, Function]
    },
    showTime: {
      type: Boolean
    },
    timePickerProps: {
      type: Object
    },
    showNowBtn: {
      type: Boolean,
      defaut: true
    },
    dayStartOfWeek: {
      type: Number,
      default: 0
    },
    modelValue: {
      type: [Object, String, Number]
    },
    defaultValue: {
      type: [Object, String, Number]
    },
    onChange: {
      type: [Function, Array]
    },
    onSelect: {
      type: [Function, Array]
    },
    onPopupVisibleChange: {
      type: [Function, Array]
    },
    onOk: {
      type: [Function, Array]
    },
    onClear: { type: [Function, Array] },
    onSelectShortcut: {
      type: [Function, Array]
    },
    onPickerValueChange: {
      type: [Function, Array]
    }
  },
  emits: {
    "change": (dateString, date) => {
      return true;
    },
    "update:modelValue": (dateString) => {
      return true;
    },
    "select": (dateString, date) => {
      return true;
    },
    "popup-visible-change": (popupVisible) => {
      return true;
    },
    "update:popupVisible": (popupVisible) => {
      return true;
    },
    "ok": (dateString, date) => {
      return true;
    },
    "clear": () => {
      return true;
    },
    "select-shortcut": (shortcut) => {
      return true;
    },
    "picker-value-change": (dateString, date) => {
      return true;
    },
    "update:pickerValue": (dateString, date) => {
      return true;
    }
  },
  setup(props, { emit, slots }) {
    const {
      mode,
      modelValue,
      defaultValue,
      format,
      placeholder,
      popupVisible,
      defaultPopupVisible,
      disabled,
      showTime,
      timePickerProps,
      disabledDate,
      disabledTime,
      readonly,
      locale,
      pickerValue,
      defaultPickerValue
    } = toRefs(props);
    const datePickerT = useDatePickerTransform(reactive({
      locale
    }));
    const prefixCls = getPrefixCls("picker");
    const refInput = ref();
    const computedPlaceholder = computed(() => (placeholder == null ? void 0 : placeholder.value) || {
      date: datePickerT("datePicker.placeholder.date"),
      month: datePickerT("datePicker.placeholder.month"),
      year: datePickerT("datePicker.placeholder.year"),
      week: datePickerT("datePicker.placeholder.week"),
      quarter: datePickerT("datePicker.placeholder.quarter")
    }[mode.value] || datePickerT("datePicker.placeholder.date"));
    const computedFormat = useFormat(reactive({ format, mode, showTime }));
    const inputFormat = computed(() => format && isFunction(format.value) ? (value) => {
      var _a;
      return (_a = format.value) == null ? void 0 : _a.call(format, getDateValue(value));
    } : computedFormat.value);
    const isDisabledDate = useIsDisabledDate(reactive({
      mode,
      disabledDate,
      disabledTime,
      showTime
    }));
    const needConfirm = computed(() => showTime.value);
    const confirmBtnDisabled = computed(() => needConfirm.value && (!panelValue.value || isDisabledDate(panelValue.value)));
    const { value: selectedValue, setValue: setSelectedValue } = usePickerState(reactive({ modelValue, defaultValue, format: computedFormat }));
    const [processValue, setProcessValue] = useState();
    const panelValue = computed(() => processValue.value || selectedValue.value);
    const [inputValue, setInputValue] = useState();
    const [panelVisible, setLocalPanelVisible] = useMergeState(defaultPopupVisible.value, reactive({ value: popupVisible }));
    const setPanelVisible = (newVisible) => {
      if (panelVisible.value !== newVisible) {
        setLocalPanelVisible(newVisible);
        emit("popup-visible-change", newVisible);
        emit("update:popupVisible", newVisible);
      }
    };
    const [headerValue, , headerOperations, resetHeaderValue] = useHeaderValue(reactive({
      mode,
      value: pickerValue,
      defaultValue: defaultPickerValue,
      selectedValue: panelValue,
      format: computedFormat,
      onChange: (newVal) => {
        const formattedValue = getFormattedValue(newVal, computedFormat.value);
        const dateValue = getDateValue(newVal);
        emit("picker-value-change", formattedValue, dateValue);
        emit("update:pickerValue", formattedValue, dateValue);
      }
    }));
    const [timePickerValue, , resetTimePickerValue] = useTimePickerValue(reactive({
      timePickerProps,
      selectedValue: panelValue
    }));
    const inputEditable = computed(() => !readonly.value && !isFunction(inputFormat.value));
    watch(panelVisible, (newVisible) => {
      setProcessValue(void 0);
      if (newVisible) {
        resetHeaderValue();
        resetTimePickerValue();
      }
      if (!newVisible) {
        setInputValue(void 0);
      }
    });
    function emitChange(value, emitOk) {
      const formattedValue = getFormattedValue(value, computedFormat.value);
      const dateValue = getDateValue(value);
      if (isValueChange(value, selectedValue.value)) {
        emit("update:modelValue", formattedValue);
        emit("change", formattedValue, dateValue);
      }
      if (emitOk) {
        emit("ok", formattedValue, dateValue);
      }
    }
    function confirm(value, showPanel, emitOk) {
      if (isDisabledDate(value)) {
        return;
      }
      emitChange(value, emitOk);
      setSelectedValue(value);
      setProcessValue(void 0);
      setInputValue(void 0);
      setPanelVisible(showPanel);
    }
    function select(value, emitSelect) {
      setProcessValue(value);
      setInputValue(void 0);
      if (emitSelect) {
        const formattedValue = getFormattedValue(value, computedFormat.value);
        const dateValue = getDateValue(value);
        emit("select", formattedValue, dateValue);
      }
    }
    function focusInput(index) {
      refInput.value && refInput.value.focus && refInput.value.focus(index);
    }
    function onPanelVisibleChange(visible) {
      if (disabled.value)
        return;
      setPanelVisible(visible);
    }
    function onInputClear() {
      confirm(void 0, true);
      emit("clear");
    }
    function onInputChange(e) {
      setPanelVisible(true);
      const targetValue = e.target.value;
      setInputValue(targetValue);
      if (!isValidInputValue(targetValue, computedFormat.value))
        return;
      const newValue = dayjs(targetValue, computedFormat.value);
      if (isDisabledDate(newValue))
        return;
      if (needConfirm.value) {
        select(newValue);
      } else {
        confirm(newValue, true);
      }
    }
    function onInputPressEnter() {
      confirm(panelValue.value, false);
    }
    function onPanelSelect(value) {
      if (needConfirm.value) {
        select(value, true);
      } else {
        confirm(value, false);
      }
    }
    function onPanelCellClick(value) {
      const newValue = mergeValueWithTime(getNow(), value, timePickerValue.value);
      onPanelSelect(newValue);
    }
    function onTimePickerSelect(time) {
      const newValue = mergeValueWithTime(getNow(), panelValue.value, time);
      onPanelSelect(newValue);
    }
    function onPanelConfirm() {
      confirm(panelValue.value, false, true);
    }
    function onPanelClick() {
      focusInput();
    }
    function onPanelShortcutMouseEnter(value) {
      select(value);
    }
    function onPanelShortcutMouseLeave() {
      select(selectedValue.value);
    }
    function onPanelShortcutClick(value, shortcut) {
      emit("select-shortcut", shortcut);
      confirm(value, false);
    }
    const computedTimePickerProps = computed(() => __spreadProps(__spreadValues({
      format: computedFormat.value
    }, omit((timePickerProps == null ? void 0 : timePickerProps.value) || {}, ["defaultValue"])), {
      visible: panelVisible.value
    }));
    const panelProps = computed(() => __spreadProps(__spreadValues({}, pick(props, [
      "mode",
      "shortcuts",
      "shortcutsPosition",
      "dayStartOfWeek",
      "disabledDate",
      "disabledTime",
      "showTime",
      "hideTrigger",
      "showNowBtn"
    ])), {
      prefixCls,
      format: computedFormat.value,
      value: panelValue.value,
      visible: panelVisible.value,
      showConfirmBtn: needConfirm.value,
      confirmBtnDisabled: confirmBtnDisabled.value,
      timePickerProps: computedTimePickerProps.value,
      extra: slots.extra,
      dateRender: slots.cell,
      headerValue,
      headerIcons: {
        prev: slots["icon-prev"],
        prevDouble: slots["icon-prev-double"],
        next: slots["icon-next"],
        nextDouble: slots["icon-next-double"]
      },
      headerOperations: headerOperations.value,
      timePickerValue: timePickerValue.value,
      onCellClick: onPanelCellClick,
      onTimePickerSelect,
      onConfirm: onPanelConfirm,
      onShortcutClick: onPanelShortcutClick,
      onShortcutMouseEnter: onPanelShortcutMouseEnter,
      onShortcutMouseLeave: onPanelShortcutMouseLeave,
      onTodayBtnClick: onPanelSelect
    }));
    return {
      prefixCls,
      refInput,
      panelProps,
      panelValue,
      inputValue,
      selectedValue,
      inputFormat,
      computedFormat,
      computedPlaceholder,
      panelVisible,
      inputEditable,
      needConfirm,
      onPanelVisibleChange,
      onInputClear,
      onInputChange,
      onInputPressEnter,
      onPanelClick
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_IconCalendar = resolveComponent("IconCalendar");
  const _component_DateInput = resolveComponent("DateInput");
  const _component_PickerPanel = resolveComponent("PickerPanel");
  const _component_Trigger = resolveComponent("Trigger");
  return !_ctx.hideTrigger ? (openBlock(), createBlock(_component_Trigger, mergeProps({
    key: 0,
    trigger: "click",
    "click-to-close": false,
    "popup-offset": 4
  }, _ctx.triggerProps, {
    position: _ctx.position,
    disabled: _ctx.disabled,
    "prevent-focus": true,
    "popup-visible": _ctx.panelVisible,
    "unmount-on-close": _ctx.unmountOnClose,
    "popup-container": _ctx.popupContainer,
    onPopupVisibleChange: _ctx.onPanelVisibleChange
  }), {
    content: withCtx(() => [
      createVNode(_component_PickerPanel, mergeProps(_ctx.panelProps, { onClick: _ctx.onPanelClick }), null, 16, ["onClick"])
    ]),
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createVNode(_component_DateInput, mergeProps(_ctx.$attrs, {
          ref: "refInput",
          size: _ctx.size,
          focused: _ctx.panelVisible,
          visible: _ctx.panelVisible,
          error: _ctx.error,
          disabled: _ctx.disabled,
          readonly: !_ctx.inputEditable,
          "allow-clear": _ctx.allowClear,
          placeholder: _ctx.computedPlaceholder,
          "input-value": _ctx.inputValue,
          value: _ctx.needConfirm ? _ctx.panelValue : _ctx.selectedValue,
          format: _ctx.inputFormat,
          onClear: _ctx.onInputClear,
          onChange: _ctx.onInputChange,
          onPressEnter: _ctx.onInputPressEnter
        }), {
          "suffix-icon": withCtx(() => [
            renderSlot(_ctx.$slots, "suffix-icon", {}, () => [
              createVNode(_component_IconCalendar)
            ])
          ]),
          _: 3
        }, 16, ["size", "focused", "visible", "error", "disabled", "readonly", "allow-clear", "placeholder", "input-value", "value", "format", "onClear", "onChange", "onPressEnter"])
      ])
    ]),
    _: 3
  }, 16, ["position", "disabled", "popup-visible", "unmount-on-close", "popup-container", "onPopupVisibleChange"])) : (openBlock(), createBlock(_component_PickerPanel, normalizeProps(mergeProps({ key: 1 }, __spreadValues(__spreadValues({}, _ctx.$attrs), _ctx.panelProps))), {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "extra"),
      renderSlot(_ctx.$slots, "cell"),
      renderSlot(_ctx.$slots, "icon-prev-double"),
      renderSlot(_ctx.$slots, "icon-prev"),
      renderSlot(_ctx.$slots, "icon-next"),
      renderSlot(_ctx.$slots, "icon-next-double")
    ]),
    _: 3
  }, 16));
}
var Picker = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Picker as default };
