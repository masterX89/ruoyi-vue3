import { ComponentPublicInstance, Ref } from 'vue';
import { FilterOption, Option, OptionInfo, OptionNode } from '../select/interface';
import { VirtualListRef } from '../_components/virtual-list/interface';
export declare const useOptions: ({ options, extraOptions, inputValue, filterOption, showExtraOptions, dropdownRef, optionRefs, virtualListRef, }: {
    options?: Ref<Option[]> | undefined;
    extraOptions?: Ref<Option[]> | undefined;
    inputValue?: Ref<string> | undefined;
    filterOption?: Ref<FilterOption> | undefined;
    showExtraOptions?: Ref<boolean> | undefined;
    dropdownRef?: Ref<ComponentPublicInstance<{}, {}, {}, {}, {}, {}, {}, {}, false, import("vue").ComponentOptionsBase<any, any, any, any, any, any, any, any, any, {}>> | undefined> | undefined;
    optionRefs?: Ref<Record<string | number, HTMLElement>> | undefined;
    virtualListRef?: Ref<VirtualListRef> | undefined;
}) => {
    nodes: Ref<({
        [x: string]: any;
        value: string | number;
        label: string;
        render?: import("vue").RenderFunction | undefined;
        disabled?: boolean | undefined;
        tagProps?: any;
        key: string;
    } | {
        [x: string]: any;
        isGroup: true;
        label: string;
        options: {
            [x: number]: {
                [x: string]: any;
                value: string | number;
                label: string;
                render?: import("vue").RenderFunction | undefined;
                disabled?: boolean | undefined;
                tagProps?: any;
                key: string;
            } | any | (string & import("../select/interface").OptionData & {
                key: string;
            }) | (string & import("../select/interface").GroupOption & {
                options: OptionNode[];
                key: string;
            }) | (number & import("../select/interface").OptionData & {
                key: string;
            }) | (number & import("../select/interface").GroupOption & {
                options: OptionNode[];
                key: string;
            }) | {
                [x: string]: any;
                value: string | number;
                label: string;
                render?: import("vue").RenderFunction | undefined;
                disabled?: boolean | undefined;
                tagProps?: any;
                isGroup: true;
                options: any;
                key: string;
            } | {
                [x: string]: any;
                isGroup: true;
                label: string;
                options: (string | number | {
                    [x: string]: any;
                    value: string | number;
                    label: string;
                    render?: import("vue").RenderFunction | undefined;
                    disabled?: boolean | undefined;
                    tagProps?: any;
                } | {
                    [x: string]: any;
                    isGroup: true;
                    label: string;
                    options: (string | number | {
                        [x: string]: any;
                        value: string | number;
                        label: string;
                        render?: import("vue").RenderFunction | undefined;
                        disabled?: boolean | undefined;
                        tagProps?: any;
                    } | any)[];
                })[];
                value: string | number;
                render?: import("vue").RenderFunction | undefined;
                disabled?: boolean | undefined;
                tagProps?: any;
                key: string;
            };
            length: number;
            toString: (() => string) & (() => string);
            toLocaleString: (() => string) & (() => string);
            pop: (() => Option | undefined) & (() => OptionNode | undefined);
            push: ((...items: Option[]) => number) & ((...items: OptionNode[]) => number);
            concat: {
                (...items: ConcatArray<Option>[]): Option[];
                (...items: (Option | ConcatArray<Option>)[]): Option[];
            } & {
                (...items: ConcatArray<OptionNode>[]): OptionNode[];
                (...items: (OptionNode | ConcatArray<OptionNode>)[]): OptionNode[];
            };
            join: ((separator?: string | undefined) => string) & ((separator?: string | undefined) => string);
            reverse: (() => Option[]) & (() => OptionNode[]);
            shift: (() => Option | undefined) & (() => OptionNode | undefined);
            slice: ((start?: number | undefined, end?: number | undefined) => Option[]) & ((start?: number | undefined, end?: number | undefined) => OptionNode[]);
            sort: ((compareFn?: ((a: Option, b: Option) => number) | undefined) => Option[] & OptionNode[]) & ((compareFn?: ((a: OptionNode, b: OptionNode) => number) | undefined) => Option[] & OptionNode[]);
            splice: {
                (start: number, deleteCount?: number | undefined): Option[];
                (start: number, deleteCount: number, ...items: Option[]): Option[];
            } & {
                (start: number, deleteCount?: number | undefined): OptionNode[];
                (start: number, deleteCount: number, ...items: OptionNode[]): OptionNode[];
            };
            unshift: ((...items: Option[]) => number) & ((...items: OptionNode[]) => number);
            indexOf: ((searchElement: Option, fromIndex?: number | undefined) => number) & ((searchElement: OptionNode, fromIndex?: number | undefined) => number);
            lastIndexOf: ((searchElement: Option, fromIndex?: number | undefined) => number) & ((searchElement: OptionNode, fromIndex?: number | undefined) => number);
            every: {
                <S extends Option>(predicate: (value: Option, index: number, array: Option[]) => value is S, thisArg?: any): this is S[];
                (predicate: (value: Option, index: number, array: Option[]) => unknown, thisArg?: any): boolean;
            } & {
                <S_1 extends OptionNode>(predicate: (value: OptionNode, index: number, array: OptionNode[]) => value is S_1, thisArg?: any): this is S_1[];
                (predicate: (value: OptionNode, index: number, array: OptionNode[]) => unknown, thisArg?: any): boolean;
            };
            some: ((predicate: (value: Option, index: number, array: Option[]) => unknown, thisArg?: any) => boolean) & ((predicate: (value: OptionNode, index: number, array: OptionNode[]) => unknown, thisArg?: any) => boolean);
            forEach: ((callbackfn: (value: Option, index: number, array: Option[]) => void, thisArg?: any) => void) & ((callbackfn: (value: OptionNode, index: number, array: OptionNode[]) => void, thisArg?: any) => void);
            map: (<U>(callbackfn: (value: Option, index: number, array: Option[]) => U, thisArg?: any) => U[]) & (<U_1>(callbackfn: (value: OptionNode, index: number, array: OptionNode[]) => U_1, thisArg?: any) => U_1[]);
            filter: {
                <S_2 extends Option>(predicate: (value: Option, index: number, array: Option[]) => value is S_2, thisArg?: any): S_2[];
                (predicate: (value: Option, index: number, array: Option[]) => unknown, thisArg?: any): Option[];
            } & {
                <S_3 extends OptionNode>(predicate: (value: OptionNode, index: number, array: OptionNode[]) => value is S_3, thisArg?: any): S_3[];
                (predicate: (value: OptionNode, index: number, array: OptionNode[]) => unknown, thisArg?: any): OptionNode[];
            };
            reduce: {
                (callbackfn: (previousValue: Option, currentValue: Option, currentIndex: number, array: Option[]) => Option): Option;
                (callbackfn: (previousValue: Option, currentValue: Option, currentIndex: number, array: Option[]) => Option, initialValue: Option): Option;
                <U_2>(callbackfn: (previousValue: U_2, currentValue: Option, currentIndex: number, array: Option[]) => U_2, initialValue: U_2): U_2;
            } & {
                (callbackfn: (previousValue: OptionNode, currentValue: OptionNode, currentIndex: number, array: OptionNode[]) => OptionNode): OptionNode;
                (callbackfn: (previousValue: OptionNode, currentValue: OptionNode, currentIndex: number, array: OptionNode[]) => OptionNode, initialValue: OptionNode): OptionNode;
                <U_3>(callbackfn: (previousValue: U_3, currentValue: OptionNode, currentIndex: number, array: OptionNode[]) => U_3, initialValue: U_3): U_3;
            };
            reduceRight: {
                (callbackfn: (previousValue: Option, currentValue: Option, currentIndex: number, array: Option[]) => Option): Option;
                (callbackfn: (previousValue: Option, currentValue: Option, currentIndex: number, array: Option[]) => Option, initialValue: Option): Option;
                <U_4>(callbackfn: (previousValue: U_4, currentValue: Option, currentIndex: number, array: Option[]) => U_4, initialValue: U_4): U_4;
            } & {
                (callbackfn: (previousValue: OptionNode, currentValue: OptionNode, currentIndex: number, array: OptionNode[]) => OptionNode): OptionNode;
                (callbackfn: (previousValue: OptionNode, currentValue: OptionNode, currentIndex: number, array: OptionNode[]) => OptionNode, initialValue: OptionNode): OptionNode;
                <U_5>(callbackfn: (previousValue: U_5, currentValue: OptionNode, currentIndex: number, array: OptionNode[]) => U_5, initialValue: U_5): U_5;
            };
            find: {
                <S_4 extends Option>(predicate: (this: void, value: Option, index: number, obj: Option[]) => value is S_4, thisArg?: any): S_4 | undefined;
                (predicate: (value: Option, index: number, obj: Option[]) => unknown, thisArg?: any): Option | undefined;
            } & {
                <S_5 extends OptionNode>(predicate: (this: void, value: OptionNode, index: number, obj: OptionNode[]) => value is S_5, thisArg?: any): S_5 | undefined;
                (predicate: (value: OptionNode, index: number, obj: OptionNode[]) => unknown, thisArg?: any): OptionNode | undefined;
            };
            findIndex: ((predicate: (value: Option, index: number, obj: Option[]) => unknown, thisArg?: any) => number) & ((predicate: (value: OptionNode, index: number, obj: OptionNode[]) => unknown, thisArg?: any) => number);
            fill: ((value: Option, start?: number | undefined, end?: number | undefined) => Option[] & OptionNode[]) & ((value: OptionNode, start?: number | undefined, end?: number | undefined) => Option[] & OptionNode[]);
            copyWithin: ((target: number, start: number, end?: number | undefined) => Option[] & OptionNode[]) & ((target: number, start: number, end?: number | undefined) => Option[] & OptionNode[]);
            entries: (() => IterableIterator<[number, Option]>) & (() => IterableIterator<[number, OptionNode]>);
            keys: (() => IterableIterator<number>) & (() => IterableIterator<number>);
            values: (() => IterableIterator<Option>) & (() => IterableIterator<OptionNode>);
            includes: ((searchElement: Option, fromIndex?: number | undefined) => boolean) & ((searchElement: OptionNode, fromIndex?: number | undefined) => boolean);
            flatMap: (<U_6, This = undefined>(callback: (this: This, value: Option, index: number, array: Option[]) => U_6 | readonly U_6[], thisArg?: This | undefined) => U_6[]) & (<U_7, This_1 = undefined>(callback: (this: This_1, value: OptionNode, index: number, array: OptionNode[]) => U_7 | readonly U_7[], thisArg?: This_1 | undefined) => U_7[]);
            flat: (<A, D extends number = 1>(this: A, depth?: D | undefined) => FlatArray<A, D>[]) & (<A_1, D_1 extends number = 1>(this: A_1, depth?: D_1 | undefined) => FlatArray<A_1, D_1>[]);
            [Symbol.iterator]: (() => IterableIterator<Option>) & (() => IterableIterator<OptionNode>);
            [Symbol.unscopables]: (() => {
                copyWithin: boolean;
                entries: boolean;
                fill: boolean;
                find: boolean;
                findIndex: boolean;
                keys: boolean;
                values: boolean;
            }) & (() => {
                copyWithin: boolean;
                entries: boolean;
                fill: boolean;
                find: boolean;
                findIndex: boolean;
                keys: boolean;
                values: boolean;
            });
            at: ((index: number) => Option | undefined) & ((index: number) => OptionNode | undefined);
        };
        key: string;
    })[]>;
    optionInfoMap: Map<string | number, OptionInfo>;
    enabledOptionSet: Set<string | number>;
    activeOption: Ref<OptionInfo | undefined>;
    getNextActiveOption: (direction: 'up' | 'down') => OptionInfo | undefined;
    scrollIntoView: (value: string | number) => void;
};
