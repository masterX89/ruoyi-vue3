import { defineComponent, toRefs, computed, reactive, onUnmounted, provide, openBlock, createElementBlock, normalizeClass, normalizeStyle, renderSlot } from "vue";
import responsiveObserve, { responsiveArray } from "../_utils/responsive-observe.js";
import { getPrefixCls } from "../_utils/global-config.js";
import { RowContextInjectionKey } from "./context.js";
import _export_sfc from "../_virtual/plugin-vue_export-helper";
const getGutter = (gutter, screens) => {
  let result = 0;
  if (typeof gutter === "object") {
    for (let i = 0; i < responsiveArray.length; i++) {
      const breakpoint = responsiveArray[i];
      if (screens[breakpoint] && gutter[breakpoint] !== void 0) {
        result = gutter[breakpoint];
        break;
      }
    }
  } else {
    result = gutter;
  }
  return result;
};
const _sfc_main = defineComponent({
  name: "Row",
  props: {
    gutter: {
      type: [Number, Object, Array],
      default: 0
    },
    justify: {
      type: String,
      validator: (value) => {
        return [
          "start",
          "center",
          "end",
          "space-around",
          "space-between"
        ].includes(value);
      },
      default: "start"
    },
    align: {
      type: String,
      validator: (value) => {
        return ["start", "center", "end", "stretch"].includes(value);
      },
      default: "start"
    },
    div: {
      type: Boolean
    },
    wrap: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const { gutter, align, justify, div, wrap } = toRefs(props);
    const prefixCls = getPrefixCls("row");
    const classNames = computed(() => {
      return {
        [`${prefixCls}`]: !div.value,
        [`${prefixCls}-nowrap`]: !wrap.value,
        [`${prefixCls}-align-${align.value}`]: align.value,
        [`${prefixCls}-justify-${justify.value}`]: justify.value
      };
    });
    const state = reactive({
      screens: {
        xs: true,
        sm: true,
        md: true,
        lg: true,
        xl: true,
        xxl: true
      }
    });
    const subscribeToken = responsiveObserve.subscribe((screens) => {
      if (!Array.isArray(gutter.value) && typeof gutter.value === "object" || Array.isArray(gutter.value) && (typeof gutter.value[0] === "object" || typeof gutter.value[1] === "object")) {
        state.screens = screens;
      }
    });
    const gutterHorizontal = computed(() => getGutter(Array.isArray(gutter.value) ? gutter.value[0] : gutter.value, state.screens));
    const gutterVertical = computed(() => getGutter(Array.isArray(gutter.value) ? gutter.value[1] : 0, state.screens));
    const styles = computed(() => {
      const result = {};
      if ((gutterHorizontal.value || gutterVertical.value) && !div.value) {
        const marginHorizontal = -gutterHorizontal.value / 2;
        const marginVertical = -gutterVertical.value / 2;
        if (marginHorizontal) {
          result.marginLeft = `${marginHorizontal}px`;
          result.marginRight = `${marginHorizontal}px`;
        }
        if (marginVertical) {
          result.marginTop = `${marginVertical}px`;
          result.marginBottom = `${marginVertical}px`;
        }
      }
      return result;
    });
    onUnmounted(() => {
      responsiveObserve.unsubscribe(subscribeToken);
    });
    const resultGutter = computed(() => [
      gutterHorizontal.value,
      gutterVertical.value
    ]);
    provide(RowContextInjectionKey, reactive({
      gutter: resultGutter,
      div
    }));
    return {
      classNames,
      styles
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classNames),
    style: normalizeStyle(_ctx.styles)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var Row = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { Row as default };
