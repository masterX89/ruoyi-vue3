var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { defineComponent, inject, toRefs, ref, computed, watch, nextTick, createVNode, mergeProps } from "vue";
import { getPrefixCls } from "../_utils/global-config.js";
import { isUndefined, isArray, isObject, isFunction } from "../_utils/is.js";
import { getTagDataFromModelValue } from "./utils.js";
import Trigger from "../trigger/index.js";
import SelectView from "../_components/select-view/select-view.js";
import { getKeyDownHandler, CODE } from "../_utils/keyboard.js";
import DropdownPanel from "../_components/dropdown/dropdown-panel.js";
import DropDownOption from "../_components/dropdown/dropdown-option.js";
import DropDownOptGroup from "../_components/dropdown/dropdown-optgroup.js";
import { useOptions } from "../_hooks/use-options.js";
import VirtualList from "../_components/virtual-list/virtual-list.js";
import { configProviderInjectionKey } from "../config-provider/context.js";
var BaseSelect = defineComponent({
  name: "BaseSelect",
  inheritAttrs: false,
  props: {
    multiple: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: [String, Number, Array]
    },
    defaultValue: {
      type: [String, Number, Array],
      default: (props) => isUndefined(props.multiple) ? "" : []
    },
    inputValue: {
      type: String
    },
    defaultInputValue: {
      type: String,
      default: ""
    },
    size: {
      type: String,
      default: () => {
        var _a, _b;
        return (_b = (_a = inject(configProviderInjectionKey, void 0)) == null ? void 0 : _a.size) != null ? _b : "medium";
      }
    },
    placeholder: String,
    loading: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    allowSearch: {
      type: [Boolean, Object],
      default: (props) => Boolean(props.multiple)
    },
    allowCreate: {
      type: Boolean,
      default: false
    },
    maxTagCount: {
      type: Number,
      default: 0
    },
    popupContainer: {
      type: [String, Object]
    },
    bordered: {
      type: Boolean,
      default: true
    },
    defaultActiveFirstOption: {
      type: Boolean,
      default: true
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    unmountOnClose: {
      type: Boolean,
      default: true
    },
    filterOption: {
      type: [Boolean, Function],
      default: true
    },
    options: {
      type: Array,
      default: () => []
    },
    virtualListProps: {
      type: Object
    },
    triggerProps: {
      type: Object
    },
    formatLabel: {
      type: Function
    },
    fallbackOption: {
      type: [Boolean, Function],
      default: false
    },
    showExtraOptions: {
      type: Boolean,
      default: true
    },
    onChange: {
      type: [Function, Array]
    },
    onInputValueChange: {
      type: [Function, Array]
    },
    onPopupVisibleChange: {
      type: [Function, Array]
    },
    onClear: {
      type: [Function, Array]
    },
    onRemove: {
      type: [Function, Array]
    },
    onSearch: {
      type: [Function, Array]
    }
  },
  emits: [
    "update:modelValue",
    "update:inputValue",
    "update:popupVisible",
    "change",
    "inputValueChange",
    "popupVisibleChange",
    "clear",
    "remove",
    "search",
    "dropdownScroll",
    "dropdownReachBottom"
  ],
  setup(props, {
    slots,
    emit,
    attrs
  }) {
    const prefixCls = getPrefixCls("select");
    const {
      options,
      filterOption,
      showExtraOptions
    } = toRefs(props);
    const dropdownRef = ref();
    const optionRefs = ref({});
    const virtualListRef = ref();
    const _value = ref(props.defaultValue);
    const _inputValue = ref("");
    const _popupVisible = ref(false);
    const computedValue = computed(() => {
      var _a, _b;
      const mergedValue = (_a = props.modelValue) != null ? _a : _value.value;
      if (props.multiple) {
        if (!isArray(mergedValue)) {
          return mergedValue ? [mergedValue] : [];
        }
      } else if (isArray(mergedValue)) {
        return (_b = mergedValue[0]) != null ? _b : "";
      }
      return mergedValue;
    });
    const computedInputValue = computed(() => {
      var _a;
      return (_a = props.inputValue) != null ? _a : _inputValue.value;
    });
    const computedPopupVisible = computed(() => {
      var _a;
      return (_a = props.popupVisible) != null ? _a : _popupVisible.value;
    });
    const retainInputValue = computed(() => isObject(props.allowSearch) && Boolean(props.allowSearch.retainInputValue));
    computed(() => getTagDataFromModelValue(computedValue.value, optionInfoMap));
    const getFallBackOption = (value) => {
      if (isFunction(props.fallbackOption)) {
        return props.fallbackOption(value);
      }
      return {
        value,
        label: String(value)
      };
    };
    const createdOptions = computed(() => {
      const options2 = [];
      if (props.allowCreate || Boolean(props.fallbackOption)) {
        if (isArray(computedValue.value)) {
          options2.push(...computedValue.value.map(getFallBackOption));
        } else if (computedValue.value) {
          options2.push(getFallBackOption(computedValue.value));
        }
        if (props.allowCreate && computedInputValue.value) {
          options2.push(getFallBackOption(computedInputValue.value));
        }
      }
      return options2;
    });
    const {
      nodes,
      optionInfoMap,
      enabledOptionSet,
      activeOption,
      getNextActiveOption,
      scrollIntoView
    } = useOptions({
      options,
      extraOptions: createdOptions,
      inputValue: computedInputValue,
      filterOption,
      showExtraOptions,
      dropdownRef,
      optionRefs,
      virtualListRef
    });
    const updateValue = (value) => {
      _value.value = value;
      emit("update:modelValue", value);
      emit("change", value);
    };
    const updateInputValue = (inputValue) => {
      _inputValue.value = inputValue;
      emit("update:inputValue", inputValue);
      emit("inputValueChange", inputValue);
    };
    const handlePopupVisibleChange = (visible) => {
      if (computedPopupVisible.value !== visible) {
        _popupVisible.value = visible;
        emit("popupVisibleChange", visible);
      }
    };
    const checkOption = (value) => {
      if (isArray(computedValue.value) && enabledOptionSet.has(value)) {
        const newValue = computedValue.value.concat(value);
        updateValue(newValue);
      }
    };
    const uncheckOption = (value) => {
      if (isArray(computedValue.value)) {
        const newValue = computedValue.value.filter((v) => v !== value);
        updateValue(newValue);
      }
    };
    const handleSelect = (value, e) => {
      if (props.multiple) {
        if (isArray(computedValue.value)) {
          if (computedValue.value.includes(value)) {
            uncheckOption(value);
          } else {
            checkOption(value);
          }
        }
        if (!retainInputValue.value) {
          updateInputValue("");
        }
      } else {
        if (value !== computedValue.value) {
          updateValue(value);
        }
        if (retainInputValue.value) {
          const optionInfo = optionInfoMap.get(value);
          if (optionInfo) {
            updateInputValue(optionInfo.label);
          }
        }
        handlePopupVisibleChange(false);
      }
    };
    const handleMouseEnter = (value, e) => {
      const optionInfo = optionInfoMap.get(value);
      if (optionInfo) {
        activeOption.value = optionInfo;
      }
    };
    const handleMouseLeave = (value, e) => {
      activeOption.value = void 0;
    };
    const handleDropdownScroll = (e) => {
      emit("dropdownScroll", e);
    };
    const handleDropdownReachBottom = (e) => {
      emit("dropdownReachBottom", e);
    };
    const handleInputValueChange = (inputValue) => {
      if (inputValue !== computedInputValue.value) {
        if (!computedPopupVisible.value) {
          _popupVisible.value = true;
          emit("popupVisibleChange", true);
        }
        updateInputValue(inputValue);
        if (props.allowSearch) {
          emit("search", inputValue);
        }
      }
    };
    const handleKeyDown = getKeyDownHandler(new Map([[CODE.ENTER, (e) => {
      if (computedPopupVisible.value) {
        if (activeOption.value) {
          handleSelect(activeOption.value.value);
        }
      } else {
        handlePopupVisibleChange(true);
      }
      e.preventDefault();
    }], [CODE.ESC, (e) => {
      handlePopupVisibleChange(false);
      e.preventDefault();
    }], [CODE.ARROW_DOWN, (e) => {
      const next = getNextActiveOption("down");
      if (next) {
        activeOption.value = next;
        scrollIntoView(next.value);
      }
      e.preventDefault();
    }], [CODE.ARROW_UP, (e) => {
      const next = getNextActiveOption("up");
      if (next) {
        activeOption.value = next;
        scrollIntoView(next.value);
      }
      e.preventDefault();
    }]]));
    const handleRemove = (tag) => {
      if (isArray(computedValue.value)) {
        const newValue = computedValue.value.filter((v) => v !== tag);
        updateValue(newValue);
        emit("remove", tag);
      }
    };
    const handleClear = (e) => {
      e == null ? void 0 : e.stopPropagation();
      if (isArray(computedValue.value)) {
        const newValue = computedValue.value.filter((v) => {
          const optionInfo = optionInfoMap.get(v);
          return Boolean(optionInfo == null ? void 0 : optionInfo.disabled);
        });
        updateValue(newValue);
      } else {
        updateValue("");
      }
      updateInputValue("");
      emit("clear");
    };
    watch(computedPopupVisible, (visible) => {
      if (visible) {
        const currentValue = isArray(computedValue.value) ? computedValue.value[0] : computedValue.value;
        activeOption.value = enabledOptionSet.has(currentValue) ? optionInfoMap.get(currentValue) : optionInfoMap.get(Array.from(enabledOptionSet)[0]);
        nextTick(() => {
          var _a;
          if ((_a = activeOption.value) == null ? void 0 : _a.value) {
            scrollIntoView(activeOption.value.value);
          }
        });
      } else if (!retainInputValue.value) {
        updateInputValue("");
      }
    });
    const getOptionContentFunc = (item) => {
      if (isFunction(slots.option) && item.value) {
        const optionInfo = optionInfoMap.get(item.value);
        const optionSlot = slots.option;
        return () => optionSlot({
          data: optionInfo
        });
      }
      if (isFunction(item.render)) {
        return item.render;
      }
      return () => item.label;
    };
    const renderOption = (item) => {
      if (item.isGroup) {
        return createVNode(DropDownOptGroup, mergeProps(item._props, {
          "key": item.key,
          "label": item.label
        }), __spreadProps(__spreadValues({}, item._slots), {
          default: () => item.options.map((item2) => renderOption(item2))
        }));
      }
      const {
        value = ""
      } = item;
      const isSelected = isArray(computedValue.value) ? computedValue.value.includes(value) : value === computedValue.value;
      return createVNode(DropDownOption, mergeProps(item._props, {
        "ref": (ref2) => {
          if (ref2 == null ? void 0 : ref2.$el) {
            optionRefs.value[value] = ref2.$el;
          }
        },
        "key": item.key,
        "value": item.value,
        "label": item.label,
        "disabled": item.disabled,
        "component": props.virtualListProps ? "div" : "li",
        "isSelected": isSelected,
        "isActive": activeOption.value && value === activeOption.value.value,
        "multiple": props.multiple,
        "onClick": handleSelect,
        "onMouseenter": handleMouseEnter,
        "onMouseleave": handleMouseLeave
      }), __spreadProps(__spreadValues({}, item._slots), {
        default: getOptionContentFunc(item)
      }));
    };
    const renderDropDown = () => {
      const vSlots = __spreadValues({
        empty: slots.empty,
        footer: slots.footer
      }, props.virtualListProps ? {
        "virtual-list": () => createVNode(VirtualList, mergeProps(props.virtualListProps, {
          "ref": virtualListRef,
          "data": nodes.value
        }), {
          item: ({
            item
          }) => renderOption(item)
        })
      } : {
        default: () => nodes.value.map((item) => renderOption(item))
      });
      return createVNode(DropdownPanel, {
        "ref": dropdownRef,
        "class": `${prefixCls}-dropdown`,
        "loading": props.loading,
        "isEmpty": nodes.value.length === 0,
        "onScroll": handleDropdownScroll,
        "onReachBottom": handleDropdownReachBottom
      }, vSlots);
    };
    return () => createVNode(Trigger, mergeProps(props.triggerProps, {
      "trigger": "click",
      "disabled": props.disabled,
      "position": "bl",
      "popupOffset": 4,
      "animationName": "slide-dynamic-origin",
      "popupVisible": computedPopupVisible.value,
      "unmountOnClose": props.unmountOnClose,
      "hideEmpty": true,
      "clickToClose": !(props.allowSearch || props.allowCreate),
      "preventFocus": true,
      "popupContainer": props.popupContainer,
      "onPopupVisibleChange": handlePopupVisibleChange,
      "autoFitPopupWidth": true,
      "autoFitTransformOrigin": true
    }), {
      default: () => [createVNode(SelectView, mergeProps(attrs, {
        "class": prefixCls,
        "modelValue": getTagDataFromModelValue(computedValue.value, optionInfoMap),
        "inputValue": computedInputValue.value,
        "multiple": props.multiple,
        "disabled": props.disabled,
        "error": props.error,
        "loading": props.loading,
        "allowClear": props.allowClear,
        "allowCreate": props.allowCreate,
        "allowSearch": Boolean(props.allowSearch),
        "opened": computedPopupVisible.value,
        "maxTagCount": props.maxTagCount,
        "placeholder": props.placeholder,
        "bordered": props.bordered,
        "size": props.size,
        "formatLabel": props.formatLabel,
        "onInputValueChange": handleInputValueChange,
        "onRemove": handleRemove,
        "onClear": handleClear,
        "onKeydown": handleKeyDown
      }), {
        label: slots.label
      })],
      content: renderDropDown
    });
  }
});
export { BaseSelect as default };
