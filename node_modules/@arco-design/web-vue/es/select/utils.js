var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { isArray, isUndefined } from "../_utils/is.js";
import { isNamedComponent, resolveProps, isSlotsChildren, isArrayChildren, getChildrenString } from "../_utils/vue-utils.js";
import { omit } from "../_utils/omit.js";
const travelSelectChildren = (children) => {
  var _a, _b, _c, _d;
  const options = [];
  for (const child of children) {
    if (!child)
      continue;
    if (isNamedComponent(child, "Optgroup")) {
      const props = resolveProps(child);
      let slots;
      let groupOptions = [];
      if (isSlotsChildren(child, child.children)) {
        slots = child.children;
        if (child.children.default) {
          groupOptions = travelSelectChildren(child.children.default());
        }
      } else if (isArrayChildren(child, child.children)) {
        groupOptions = travelSelectChildren(child.children);
      }
      options.push({
        isGroup: true,
        label: props.label,
        options: groupOptions,
        _props: props,
        _slots: slots
      });
    } else if (isNamedComponent(child, "Option")) {
      const props = resolveProps(child);
      let slots;
      let childrenString = "";
      let render;
      if (isSlotsChildren(child, child.children)) {
        slots = child.children;
        if (child.children.default) {
          render = child.children.default;
          childrenString = getChildrenString(child.children.default());
        }
      }
      options.push(__spreadProps(__spreadValues({}, props.extra), {
        value: (_a = props.value) != null ? _a : childrenString,
        label: (_b = props.label) != null ? _b : childrenString,
        render,
        disabled: props.disabled,
        tagProps: props.tagProps,
        _props: omit(props, ["tagProps", "extra"]),
        _slots: slots
      }));
    } else if (isArrayChildren(child, child.children)) {
      options.push(...travelSelectChildren(child.children));
    } else if (isSlotsChildren(child, child.children)) {
      const _children = (_d = (_c = child.children).default) == null ? void 0 : _d.call(_c);
      if (_children) {
        options.push(...travelSelectChildren(_children));
      }
    } else if (isArray(child)) {
      options.push(...travelSelectChildren(child));
    }
  }
  return options;
};
const getTagData = (value, optionInfoMap) => {
  if (isUndefined(value)) {
    return void 0;
  }
  const optionInfo = optionInfoMap.get(value);
  if (!optionInfo) {
    return void 0;
  }
  return __spreadProps(__spreadValues({}, optionInfo), {
    label: optionInfo.label,
    closable: !optionInfo.disabled
  });
};
const getTagDataFromModelValue = (modelValue, optionInfoMap) => {
  if (isArray(modelValue)) {
    const result = [];
    for (const item of modelValue) {
      const valueData = getTagData(item, optionInfoMap);
      if (valueData) {
        result.push(valueData);
      }
    }
    return result;
  }
  return getTagData(modelValue, optionInfoMap);
};
export { getTagDataFromModelValue, travelSelectChildren };
