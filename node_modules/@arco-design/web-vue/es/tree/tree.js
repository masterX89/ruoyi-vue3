import { defineComponent, toRefs, computed, reactive, ref, provide, resolveComponent, openBlock, createElementBlock, normalizeClass, createBlock, mergeProps, withCtx, createVNode, Fragment, renderList } from "vue";
import { getPrefixCls } from "../_utils/global-config.js";
import { TreeInjectionKey } from "./context.js";
import usePickSlots from "../_hooks/use-pick-slots.js";
import { isNodeCheckable, getCheckedStateByCheck } from "./utils/index.js";
import TreeNode from "./node.js";
import { isUndefined, isFunction } from "../_utils/is.js";
import useMergeState from "../_hooks/use-merge-state.js";
import useCheckedState from "./hooks/use-checked-state.js";
import useTreeData from "./hooks/use-tree-data.js";
import VirtualList from "../_components/virtual-list/virtual-list.js";
import _export_sfc from "../_virtual/plugin-vue_export-helper";
const _sfc_main = defineComponent({
  name: "Tree",
  components: {
    VirtualList,
    TreeNode
  },
  props: {
    size: {
      type: String,
      default: "medium"
    },
    blockNode: {
      type: Boolean
    },
    defaultExpandAll: {
      type: Boolean,
      default: true
    },
    multiple: {
      type: Boolean
    },
    checkable: {
      type: Boolean
    },
    selectable: {
      type: Boolean,
      default: true
    },
    checkStrictly: {
      type: Boolean
    },
    checkedStrategy: {
      type: String,
      default: "all"
    },
    defaultSelectedKeys: {
      type: Array
    },
    selectedKeys: {
      type: Array
    },
    defaultCheckedKeys: {
      type: Array
    },
    checkedKeys: {
      type: Array
    },
    defaultExpandedKeys: {
      type: Array
    },
    expandedKeys: {
      type: Array
    },
    data: {
      type: Array,
      default: () => []
    },
    fieldNames: {
      type: Object
    },
    showLine: {
      type: Boolean
    },
    loadMore: {
      type: Function
    },
    draggable: {
      type: Boolean
    },
    allowDrop: {
      type: Function
    },
    filterTreeNode: {
      type: Function
    },
    virtualListProps: {
      type: Object
    },
    defaultExpandSelected: {
      type: Boolean
    },
    defaultExpandChecked: {
      type: Boolean
    },
    autoExpandParent: {
      type: Boolean,
      default: true
    }
  },
  emits: [
    "select",
    "update:selectedKeys",
    "check",
    "update:checkedKeys",
    "expand",
    "update:expandedKeys",
    "dragStart",
    "dragEnd",
    "dragOver",
    "dragLeave",
    "drop"
  ],
  setup(props, { emit, slots }) {
    const {
      data: propTreeData,
      showLine,
      multiple,
      loadMore,
      checkStrictly,
      checkedKeys: propCheckedKeys,
      defaultCheckedKeys,
      selectedKeys: propSelectedKeys,
      defaultSelectedKeys,
      expandedKeys: propExpandedKeys,
      defaultExpandedKeys,
      checkedStrategy,
      selectable,
      checkable,
      blockNode,
      fieldNames,
      size,
      defaultExpandAll,
      filterTreeNode,
      draggable,
      allowDrop,
      defaultExpandSelected,
      defaultExpandChecked,
      autoExpandParent
    } = toRefs(props);
    const prefixCls = getPrefixCls("tree");
    const classNames = computed(() => [
      `${prefixCls}`,
      {
        [`${prefixCls}-checkable`]: checkable.value,
        [`${prefixCls}-show-line`]: showLine.value
      },
      `${prefixCls}-size-${size.value}`
    ]);
    const switcherIcon = usePickSlots(slots, "switcher-icon");
    const loadingIcon = usePickSlots(slots, "loading-icon");
    const dragIcon = usePickSlots(slots, "drag-icon");
    const nodeTitle = usePickSlots(slots, "title");
    const nodeExtra = usePickSlots(slots, "extra");
    const { treeData, flattenTreeData, key2TreeNode } = useTreeData(reactive({
      treeData: propTreeData,
      selectable,
      showLine,
      blockNode,
      checkable,
      fieldNames,
      loadMore,
      draggable
    }));
    const { checkedKeys, indeterminateKeys, setCheckedState } = useCheckedState(reactive({
      defaultCheckedKeys,
      checkedKeys: propCheckedKeys,
      checkStrictly,
      key2TreeNode
    }));
    const [selectedKeys, setSelectedKeys] = useMergeState((defaultSelectedKeys == null ? void 0 : defaultSelectedKeys.value) || [], reactive({
      value: propSelectedKeys
    }));
    const loadingKeys = ref([]);
    const dragNode = ref();
    function getDefaultExpandedKeys() {
      if (defaultExpandedKeys == null ? void 0 : defaultExpandedKeys.value) {
        const expandedKeysSet = new Set([]);
        defaultExpandedKeys.value.forEach((_key) => {
          if (expandedKeysSet.has(_key))
            return;
          const node = key2TreeNode.value[_key];
          if (!node)
            return;
          [
            ...autoExpandParent.value ? node.pathParentKeys : [],
            _key
          ].forEach((_key2) => expandedKeysSet.add(_key2));
        });
        return [...expandedKeysSet];
      }
      if (defaultExpandAll.value) {
        return flattenTreeData.value.filter((node) => node.children && node.children.length).map((node) => node.key);
      }
      if (defaultSelectedKeys.value || defaultExpandChecked.value) {
        const expandedKeysSet = new Set([]);
        const addToExpandKeysSet = (keys) => {
          keys.forEach((key) => {
            const node = key2TreeNode.value[key];
            if (!node)
              return;
            (node.pathParentKeys || []).forEach((k) => expandedKeysSet.add(k));
          });
        };
        if (defaultExpandSelected.value) {
          addToExpandKeysSet(selectedKeys.value);
        }
        if (defaultExpandChecked.value) {
          addToExpandKeysSet(checkedKeys.value);
        }
        return [...expandedKeysSet];
      }
      return [];
    }
    const [expandedKeys, setExpandKeys] = useMergeState(getDefaultExpandedKeys(), reactive({
      value: propExpandedKeys
    }));
    const currentExpandKeys = ref([]);
    const visibleTreeNodeList = computed(() => {
      const expandedKeysSet = new Set(expandedKeys.value);
      const currentExpandKeysSet = new Set(currentExpandKeys.value);
      return flattenTreeData.value.filter((node) => {
        var _a;
        const passFilter = !filterTreeNode || !filterTreeNode.value || (filterTreeNode == null ? void 0 : filterTreeNode.value(node.treeNodeData));
        if (!passFilter)
          return false;
        const isRoot = isUndefined(node.parentKey);
        const isVisibleNode = (_a = node.pathParentKeys) == null ? void 0 : _a.every((_key) => expandedKeysSet.has(_key) && !currentExpandKeysSet.has(_key));
        return isRoot || isVisibleNode;
      });
    });
    function onCheck(checked, key, e) {
      const node = key2TreeNode.value[key];
      if (!node)
        return;
      const [newCheckedKeys, newIndeterminateKeys] = getCheckedStateByCheck({
        node,
        checked,
        checkedKeys: checkedKeys.value,
        indeterminateKeys: indeterminateKeys.value,
        checkStrictly: checkStrictly.value
      });
      setCheckedState(newCheckedKeys, newIndeterminateKeys);
      let publicCheckedKeys = [...newCheckedKeys];
      if (checkedStrategy.value === "parent") {
        publicCheckedKeys = newCheckedKeys.filter((_key) => {
          const item = key2TreeNode.value[_key];
          return !(!isUndefined(item.parentKey) && newCheckedKeys.includes(item.parentKey));
        });
      } else if (checkedStrategy.value === "child") {
        publicCheckedKeys = newCheckedKeys.filter((_key) => {
          var _a;
          const item = key2TreeNode.value[_key];
          return !((_a = item.children) == null ? void 0 : _a.length);
        });
      }
      emit("check", publicCheckedKeys, {
        checked,
        node: node.treeNodeData,
        checkedNodes: publicCheckedKeys.map((v) => {
          var _a;
          return (_a = key2TreeNode.value[v]) == null ? void 0 : _a.treeNodeData;
        }),
        e
      });
      emit("update:checkedKeys", publicCheckedKeys);
    }
    function onSelect(key, e) {
      const node = key2TreeNode.value[key];
      if (!node)
        return;
      let newSelectedKeys;
      let selected;
      if (multiple.value) {
        const selectedKeysSet = new Set(selectedKeys.value);
        selected = !selectedKeysSet.has(key);
        selected ? selectedKeysSet.add(key) : selectedKeysSet.delete(key);
        newSelectedKeys = [...selectedKeysSet];
      } else {
        selected = true;
        newSelectedKeys = [key];
      }
      setSelectedKeys(newSelectedKeys);
      emit("select", newSelectedKeys, {
        selected,
        node: node.treeNodeData,
        selectedNodes: newSelectedKeys.map((v) => {
          var _a;
          return (_a = key2TreeNode.value[v]) == null ? void 0 : _a.treeNodeData;
        }),
        e
      });
      emit("update:selectedKeys", newSelectedKeys);
    }
    function onExpand(expanded, key, e) {
      if (currentExpandKeys.value.includes(key))
        return;
      const node = key2TreeNode.value[key];
      if (!node)
        return;
      const expandedKeysSet = new Set(expandedKeys.value);
      expanded ? expandedKeysSet.add(key) : expandedKeysSet.delete(key);
      const newExpandedKeys = [...expandedKeysSet];
      setExpandKeys(newExpandedKeys);
      currentExpandKeys.value.push(key);
      emit("expand", newExpandedKeys, {
        expanded,
        node: node.treeNodeData,
        expandedNodes: newExpandedKeys.map((v) => {
          var _a;
          return (_a = key2TreeNode.value[v]) == null ? void 0 : _a.treeNodeData;
        }),
        e
      });
      emit("update:expandedKeys", newExpandedKeys);
    }
    function onExpandEnd(key) {
      const index = currentExpandKeys.value.indexOf(key);
      currentExpandKeys.value.splice(index, 1);
    }
    const onLoadMore = computed(() => (loadMore == null ? void 0 : loadMore.value) ? async (key) => {
      if (!isFunction(loadMore.value))
        return;
      const node = key2TreeNode.value[key];
      if (!node)
        return;
      const { treeNodeData } = node;
      loadingKeys.value = [...new Set([...loadingKeys.value, key])];
      try {
        await loadMore.value(treeNodeData);
        loadingKeys.value = loadingKeys.value.filter((v) => v !== key);
        onExpand(true, key);
        if (checkedKeys.value.includes(key)) {
          onCheck(true, key);
        }
      } catch (err) {
        loadingKeys.value = loadingKeys.value.filter((v) => v !== key);
        console.error("[tree]load data error: ", err);
      }
    } : void 0);
    const treeContext = reactive({
      switcherIcon,
      loadingIcon,
      dragIcon,
      nodeTitle,
      nodeExtra,
      treeData,
      flattenTreeData,
      key2TreeNode,
      checkedKeys,
      indeterminateKeys,
      selectedKeys,
      expandedKeys,
      loadingKeys,
      currentExpandKeys,
      onLoadMore,
      onCheck,
      onSelect,
      onExpand,
      onExpandEnd,
      allowDrop(key, dropPosition) {
        const nodeData = key2TreeNode.value[key];
        if (nodeData && isFunction(allowDrop == null ? void 0 : allowDrop.value)) {
          return !!(allowDrop == null ? void 0 : allowDrop.value({
            dropNode: nodeData,
            dropPosition
          }));
        }
        return true;
      },
      onDragStart(key, e) {
        const nodeData = key2TreeNode.value[key];
        dragNode.value = nodeData;
        if (nodeData) {
          emit("dragStart", e, nodeData);
        }
      },
      onDragEnd(key, e) {
        const nodeData = key2TreeNode.value[key];
        dragNode.value = void 0;
        if (nodeData) {
          emit("dragEnd", e, nodeData);
        }
      },
      onDragOver(key, e) {
        const nodeData = key2TreeNode.value[key];
        if (nodeData) {
          emit("dragOver", e, nodeData);
        }
      },
      onDragLeave(key, e) {
        const nodeData = key2TreeNode.value[key];
        if (nodeData) {
          emit("dragLeave", e, nodeData);
        }
      },
      onDrop(key, dropPosition, e) {
        const nodeData = key2TreeNode.value[key];
        if (dragNode.value && nodeData && !(nodeData.key === dragNode.value.key || nodeData.pathParentKeys.includes(dragNode.value.key || ""))) {
          emit("drop", {
            e,
            dragNode: dragNode.value,
            dropNode: nodeData,
            dropPosition
          });
        }
      }
    });
    provide(TreeInjectionKey, treeContext);
    return {
      classNames,
      visibleTreeNodeList,
      treeContext,
      virtualListRef: ref()
    };
  },
  methods: {
    toggleCheck(key, e) {
      const { key2TreeNode, onCheck, checkedKeys } = this.treeContext;
      const checked = !checkedKeys.includes(key);
      const node = key2TreeNode[key];
      if (node && isNodeCheckable(node)) {
        onCheck(checked, key, e);
      }
    },
    scrollIntoView(options) {
      this.virtualListRef && this.virtualListRef.scrollTo(options);
    }
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TreeNode = resolveComponent("TreeNode");
  const _component_VirtualList = resolveComponent("VirtualList");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classNames)
  }, [
    _ctx.virtualListProps ? (openBlock(), createBlock(_component_VirtualList, mergeProps({
      key: 0,
      ref: "virtualListRef"
    }, _ctx.virtualListProps, { data: _ctx.visibleTreeNodeList }), {
      item: withCtx(({ item: node }) => [
        createVNode(_component_TreeNode, mergeProps({
          key: node.key
        }, node.treeNodeProps), null, 16)
      ]),
      _: 1
    }, 16, ["data"])) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(_ctx.visibleTreeNodeList, (node) => {
      return openBlock(), createBlock(_component_TreeNode, mergeProps({
        key: node.key
      }, node.treeNodeProps), null, 16);
    }), 128))
  ], 2);
}
var _Tree = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _Tree as default };
