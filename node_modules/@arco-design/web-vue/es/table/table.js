var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { defineComponent, inject, toRefs, computed, ref, onMounted, watch, watchEffect, reactive, createVNode, Fragment, mergeProps, isVNode } from "vue";
import { getPrefixCls } from "../_utils/global-config.js";
import { off, on } from "../_utils/dom.js";
import { isObject, isString, isFunction, isNumber, isArray } from "../_utils/is.js";
import { getColumnsFromSlot, getGroupColumns } from "./utils.js";
import { useRowSelection } from "./hooks/use-row-selection.js";
import { useExpand } from "./hooks/use-expand.js";
import { usePagination } from "./hooks/use-pagination.js";
import IconPlus from "../icon/icon-plus/index.js";
import IconMinus from "../icon/icon-minus/index.js";
import Spin from "../spin/index.js";
import Pagination from "../pagination/index.js";
import Empty from "../empty/index.js";
import ColGroup from "./table-col-group.js";
import Thead from "./table-thead.js";
import Tbody from "./table-tbody.js";
import Tr from "./table-tr.js";
import Th from "./table-th.js";
import Td from "./table-td.js";
import OperationTh from "./table-operation-th.js";
import OperationTd from "./table-operation-td.js";
import VirtualList from "../_components/virtual-list/virtual-list.js";
import ResizeObserver from "../_components/resize-observer.js";
import usePickSlots from "../_hooks/use-pick-slots.js";
import { omit } from "../_utils/omit.js";
import { getChildrenComponents } from "../_utils/vue-utils.js";
import { configProviderInjectionKey } from "../config-provider/context.js";
function _isSlot(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const DEFAULT_BORDERED = {
  wrapper: true,
  cell: false,
  headerCell: false,
  bodyCell: false
};
var _Table = defineComponent({
  name: "Table",
  props: {
    columns: {
      type: Array,
      default: () => []
    },
    data: {
      type: Array,
      default: () => []
    },
    bordered: {
      type: [Boolean, Object],
      default: true
    },
    hoverable: {
      type: Boolean,
      default: true
    },
    stripe: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: () => {
        var _a, _b;
        return (_b = (_a = inject(configProviderInjectionKey, void 0)) == null ? void 0 : _a.size) != null ? _b : "large";
      }
    },
    tableLayoutFixed: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    hideHeader: {
      type: Boolean,
      default: false
    },
    rowSelection: {
      type: Object
    },
    expandable: {
      type: Object
    },
    scroll: {
      type: Object
    },
    pagination: {
      type: [Boolean, Object],
      default: true
    },
    pagePosition: {
      type: String,
      default: "br"
    },
    indentSize: {
      type: Number,
      default: 16
    },
    rowKey: {
      type: String,
      default: "key"
    },
    showHeader: {
      type: Boolean,
      default: true
    },
    virtualListProps: {
      type: Object
    },
    spanMethod: {
      type: Function
    },
    components: {
      type: Object
    },
    loadMore: {
      type: Function
    },
    filterIconAlignLeft: {
      type: Boolean,
      default: false
    },
    hideExpandButtonOnEmpty: {
      type: Boolean,
      default: false
    },
    onExpand: {
      type: [Function, Array]
    },
    onExpandedChange: {
      type: [Function, Array]
    },
    onSelect: {
      type: [Function, Array]
    },
    onSelectAll: {
      type: [Function, Array]
    },
    onSelectionChange: {
      type: [Function, Array]
    },
    onSorterChange: {
      type: [Function, Array]
    },
    onFilterChange: {
      type: [Function, Array]
    },
    onPageChange: {
      type: [Function, Array]
    },
    onPageSizeChange: {
      type: [Function, Array]
    },
    onCellClick: {
      type: [Function, Array]
    },
    onRowClick: {
      type: [Function, Array]
    },
    onHeaderClick: {
      type: [Function, Array]
    }
  },
  emits: [
    "expand",
    "expandedChange",
    "select",
    "selectAll",
    "selectionChange",
    "sorterChange",
    "filterChange",
    "pageChange",
    "pageSizeChange",
    "change",
    "cellClick",
    "rowClick",
    "headerClick"
  ],
  setup(props, {
    emit,
    slots
  }) {
    const {
      rowKey
    } = toRefs(props);
    const prefixCls = getPrefixCls("table");
    const bordered = computed(() => {
      if (isObject(props.bordered)) {
        return __spreadValues(__spreadValues({}, DEFAULT_BORDERED), props.bordered);
      }
      return __spreadProps(__spreadValues({}, DEFAULT_BORDERED), {
        wrapper: props.bordered
      });
    });
    const isScroll = computed(() => {
      var _a, _b;
      const x = Boolean((_a = props.scroll) == null ? void 0 : _a.x);
      const y = Boolean((_b = props.scroll) == null ? void 0 : _b.y);
      return {
        x,
        y
      };
    });
    const theadRef = ref();
    const tbodyRef = ref();
    const handleBodyScroll = () => {
      if (theadRef.value && tbodyRef.value) {
        theadRef.value.scrollLeft = tbodyRef.value.scrollLeft;
      }
    };
    onMounted(() => {
      watch(isScroll, ({
        y
      }, _, onInvalidate) => {
        onInvalidate(() => {
          if (tbodyRef.value) {
            off(tbodyRef.value, "scroll", handleBodyScroll);
          }
        });
        if (y && tbodyRef.value && theadRef.value) {
          on(tbodyRef.value, "scroll", handleBodyScroll);
        }
      });
    });
    const columnsSlot = usePickSlots(slots, "columns");
    const slotColumns = computed(() => {
      if (columnsSlot.value) {
        return getColumnsFromSlot(getChildrenComponents(columnsSlot.value(), "TableColumn"));
      }
      return void 0;
    });
    const dataColumns = ref([]);
    const groupColumns = ref([]);
    watch(() => [props.columns, slotColumns.value], ([columns, slotColumns2]) => {
      var _a;
      const result = getGroupColumns((_a = slotColumns2 != null ? slotColumns2 : columns) != null ? _a : []);
      dataColumns.value = result.dataColumns;
      groupColumns.value = result.groupColumns;
    }, {
      immediate: true
    });
    const isPaginationTop = computed(() => ["tl", "top", "tr"].includes(props.pagePosition));
    const hasLeftFixedColumn = ref(false);
    const hasRightFixedColumn = ref(false);
    watchEffect(() => {
      var _a, _b;
      let _hasLeftFixedColumn = false;
      let _hasRightFixedColumn = false;
      if (((_a = props.rowSelection) == null ? void 0 : _a.fixed) || ((_b = props.expandable) == null ? void 0 : _b.fixed)) {
        _hasLeftFixedColumn = true;
      }
      for (const column of dataColumns.value) {
        if (column.fixed === "left") {
          _hasLeftFixedColumn = true;
        } else if (column.fixed === "right") {
          _hasRightFixedColumn = true;
        }
      }
      if (_hasLeftFixedColumn !== hasLeftFixedColumn.value) {
        hasLeftFixedColumn.value = _hasLeftFixedColumn;
      }
      if (_hasRightFixedColumn !== hasRightFixedColumn.value) {
        hasRightFixedColumn.value = _hasRightFixedColumn;
      }
    });
    const hasEllipsis = computed(() => {
      for (const col of dataColumns.value) {
        if (col.ellipsis) {
          return true;
        }
      }
      return false;
    });
    const outerFilters = computed(() => {
      var _a;
      const filters = {};
      for (const item of dataColumns.value) {
        if (item.dataIndex && ((_a = item.filterable) == null ? void 0 : _a.filteredValue)) {
          filters[item.dataIndex] = item.filterable.filteredValue;
        }
      }
      return filters;
    });
    const getDefaultFilters = () => {
      var _a;
      const filters = {};
      for (const item of dataColumns.value) {
        if (item.dataIndex && ((_a = item.filterable) == null ? void 0 : _a.defaultFilteredValue)) {
          filters[item.dataIndex] = item.filterable.defaultFilteredValue;
        }
      }
      return filters;
    };
    const getDefaultSorter = () => {
      var _a;
      for (const item of dataColumns.value) {
        if (item.dataIndex && ((_a = item.sortable) == null ? void 0 : _a.defaultSortOrder)) {
          return {
            filed: item.dataIndex,
            direction: item.sortable.defaultSortOrder
          };
        }
      }
      return {};
    };
    const _filters = ref(getDefaultFilters());
    const _sorter = ref(getDefaultSorter());
    const computedFilters = computed(() => __spreadValues(__spreadValues({}, _filters.value), outerFilters.value));
    const computedSorter = computed(() => {
      for (const item of dataColumns.value) {
        if (item.dataIndex && item.sortable) {
          const direction = isString(item.sortable.sortOrder) ? item.sortable.sortOrder : _sorter.value.filed === item.dataIndex ? _sorter.value.direction : "";
          if (direction) {
            return {
              filed: item.dataIndex,
              direction
            };
          }
        }
      }
      return {};
    });
    const handleFilterChange = (dataIndex, filteredValues) => {
      const newFilters = __spreadProps(__spreadValues({}, computedFilters.value), {
        [dataIndex]: filteredValues
      });
      _filters.value = newFilters;
      emit("filterChange", dataIndex, filteredValues);
      handleChange("filter");
    };
    const handleSorterChange = (dataIndex, direction) => {
      const newSorter = direction ? {
        filed: dataIndex,
        direction
      } : {};
      _sorter.value = newSorter;
      emit("sorterChange", dataIndex, direction);
      handleChange("sorter");
    };
    const getColumnByDataIndex = (dataIndex) => {
      for (const item of dataColumns.value) {
        if (item.dataIndex === dataIndex) {
          return item;
        }
      }
      return void 0;
    };
    const disabledKeys = new Set();
    const allRowKeys = computed(() => {
      const allRowKeys2 = [];
      disabledKeys.clear();
      const travelData = (data) => {
        if (isArray(data) && data.length > 0) {
          for (const record of data) {
            allRowKeys2.push(record[rowKey.value]);
            if (record.disabled) {
              disabledKeys.add(record[rowKey.value]);
            }
            if (record.children) {
              travelData(record.children);
            }
          }
        }
      };
      travelData(props.data);
      return allRowKeys2;
    });
    const currentAllRowKeys = computed(() => {
      const keys = [];
      const travel = (data) => {
        for (const record of data) {
          keys.push(record[rowKey.value]);
          if (record.children) {
            travel(record.children);
          }
        }
      };
      travel(flattenData.value);
      return keys;
    });
    const currentAllEnabledRowKeys = computed(() => {
      const keys = [];
      const travel = (data) => {
        for (const record of data) {
          if (!record.disabled) {
            keys.push(record[rowKey.value]);
          }
          if (record.children) {
            travel(record.children);
          }
        }
      };
      travel(flattenData.value);
      return keys;
    });
    const {
      isRadio,
      selectedRowKeys,
      currentSelectedRowKeys,
      handleSelect,
      handleSelectAll
    } = useRowSelection(props, {
      allRowKeys,
      currentAllRowKeys,
      currentAllEnabledRowKeys
    }, emit);
    const {
      expandedRowKeys,
      handleExpand
    } = useExpand(props, allRowKeys.value, emit);
    const lazyLoadData = reactive({});
    const addLazyLoadData = (children, record) => {
      if (children) {
        lazyLoadData[record[props.rowKey]] = children;
      }
    };
    const isValidRecord = (record) => {
      var _a, _b;
      for (const field of Object.keys(computedFilters.value)) {
        const filteredValues = computedFilters.value[field];
        const column = getColumnByDataIndex(field);
        if (column && ((_a = column.filterable) == null ? void 0 : _a.filter) && filteredValues.length > 0) {
          const result = (_b = column.filterable) == null ? void 0 : _b.filter(filteredValues, record);
          if (!result) {
            return result;
          }
        }
      }
      return true;
    };
    const processData = (origin) => {
      var _a;
      const travel = (data2) => {
        const result = [];
        for (const record of data2) {
          if (isValidRecord(record)) {
            if (props.loadMore && !record.isLeaf && !record.children && lazyLoadData[record[props.rowKey]]) {
              record.children = lazyLoadData[record[props.rowKey]];
            }
            if (record.children) {
              record.children = travel(record.children);
            }
            result.push(record);
          }
        }
        return result;
      };
      const data = travel(isArray(origin) ? origin : []);
      if (data.length > 0) {
        if (computedSorter.value.filed) {
          const column = getColumnByDataIndex(computedSorter.value.filed);
          if (column && ((_a = column.sortable) == null ? void 0 : _a.sorter) !== true) {
            data.sort((a, b) => {
              var _a2, _b, _c;
              const valueA = a[computedSorter.value.filed];
              const valueB = b[computedSorter.value.filed];
              const result = (isFunction((_a2 = column.sortable) == null ? void 0 : _a2.sorter) ? (_c = (_b = column.sortable) == null ? void 0 : _b.sorter) == null ? void 0 : _c.call(_b, valueA, valueB) : valueA > valueB) ? 1 : -1;
              return computedSorter.value.direction === "descend" ? -result : result;
            });
          }
        }
      }
      return data;
    };
    const processedData = computed(() => processData(props.data));
    const {
      page,
      pageSize,
      handlePageChange,
      handlePageSizeChange
    } = usePagination(props, emit);
    const handleChange = (type) => {
      const extra = {
        type,
        page: page.value,
        pageSize: pageSize.value,
        sorter: computedSorter.value,
        filters: computedFilters.value
      };
      emit("change", flattenData.value, extra);
    };
    const flattenData = computed(() => {
      if (props.pagination && processedData.value.length > pageSize.value) {
        return processedData.value.slice((page.value - 1) * pageSize.value, page.value * pageSize.value);
      }
      return processedData.value;
    });
    const containerRef = ref();
    const containerScrollLeft = ref(0);
    const alignLeft = ref(true);
    const alignRight = ref(true);
    const setAlignPosition = () => {
      let _alignLeft = true;
      let _alignRight = true;
      const scrollContainer = isScroll.value.y ? tbodyRef.value : containerRef.value;
      if (scrollContainer) {
        _alignLeft = containerScrollLeft.value === 0;
        _alignRight = containerScrollLeft.value + scrollContainer.offsetWidth >= scrollContainer.scrollWidth;
      }
      if (_alignLeft !== alignLeft.value) {
        alignLeft.value = _alignLeft;
      }
      if (_alignRight !== alignRight.value) {
        alignRight.value = _alignRight;
      }
    };
    const getTableScrollCls = () => {
      if (alignLeft.value && alignRight.value) {
        return `${prefixCls}-scroll-position-both`;
      }
      if (alignLeft.value) {
        return `${prefixCls}-scroll-position-left`;
      }
      if (alignRight.value) {
        return `${prefixCls}-scroll-position-right`;
      }
      return `${prefixCls}-scroll-position-middle`;
    };
    const getTableFixedCls = () => {
      const cls2 = [];
      if (hasLeftFixedColumn.value) {
        cls2.push(`${prefixCls}-has-fixed-col-left`);
      }
      if (hasRightFixedColumn.value) {
        cls2.push(`${prefixCls}-has-fixed-col-right`);
      }
      return cls2;
    };
    const handleScroll = (e) => {
      const target = e.target;
      if (target.scrollLeft !== containerScrollLeft.value) {
        containerScrollLeft.value = target.scrollLeft;
      }
      if (isScroll.value.y && theadRef.value) {
        theadRef.value.scrollLeft = target.scrollLeft;
      }
      setAlignPosition();
    };
    const handleRowClick = (record) => {
      emit("rowClick", record);
    };
    const handleCellClick = (record, column) => {
      emit("cellClick", record, column);
    };
    const handleHeaderClick = (column) => {
      emit("headerClick", column);
    };
    const getOperations = () => {
      var _a;
      const operations2 = [];
      const hasFixedColumn = hasLeftFixedColumn.value || hasRightFixedColumn.value;
      let expand;
      let selection;
      if (props.expandable) {
        expand = {
          name: "expand",
          title: props.expandable.title,
          width: props.expandable.width,
          fixed: props.expandable.fixed || hasFixedColumn
        };
        operations2.push(expand);
      }
      if (props.rowSelection) {
        selection = {
          name: "selection",
          title: props.rowSelection.title,
          width: props.rowSelection.width,
          fixed: props.rowSelection.fixed || hasFixedColumn
        };
        operations2.push(selection);
      }
      const operationsFn = (_a = props.components) == null ? void 0 : _a.operations;
      return isFunction(operationsFn) ? operationsFn({
        expand,
        selection
      }) : operations2;
    };
    const operations = computed(() => getOperations());
    const contentStyle = computed(() => {
      var _a, _b, _c;
      if (isScroll.value.x && flattenData.value.length > 0) {
        return {
          width: isNumber((_a = props.scroll) == null ? void 0 : _a.x) ? `${(_b = props.scroll) == null ? void 0 : _b.x}px` : (_c = props.scroll) == null ? void 0 : _c.x
        };
      }
      return void 0;
    });
    const cls = computed(() => [prefixCls, `${prefixCls}-size-${props.size}`, {
      [`${prefixCls}-border`]: bordered.value.wrapper,
      [`${prefixCls}-border-cell`]: bordered.value.cell,
      [`${prefixCls}-border-header-cell`]: !bordered.value.cell && bordered.value.headerCell,
      [`${prefixCls}-border-body-cell`]: !bordered.value.cell && bordered.value.bodyCell,
      [`${prefixCls}-stripe`]: props.stripe,
      [`${prefixCls}-hover`]: props.hoverable,
      [`${prefixCls}-type-selection`]: props.rowSelection,
      [`${prefixCls}-layout-fixed`]: props.tableLayoutFixed || isScroll.value.x || isScroll.value.y || hasEllipsis.value
    }]);
    const paginationCls = computed(() => [`${prefixCls}-pagination`, {
      [`${prefixCls}-pagination-left`]: props.pagePosition === "tl" || props.pagePosition === "bl",
      [`${prefixCls}-pagination-center`]: props.pagePosition === "top" || props.pagePosition === "bottom",
      [`${prefixCls}-pagination-top`]: isPaginationTop.value
    }]);
    const tableCls = computed(() => {
      const cls2 = getTableFixedCls();
      if (isScroll.value.x) {
        cls2.push(getTableScrollCls());
      }
      if (isScroll.value.y || isVirtualList.value) {
        cls2.push(`${prefixCls}-scroll-y`);
      }
      return cls2;
    });
    const thRefs = ref({
      operation: [],
      data: {}
    });
    const isVirtualList = computed(() => Boolean(props.virtualListProps));
    const hasScrollBar = ref(false);
    const isTbodyHasScrollBar = () => {
      if (tbodyRef.value) {
        return tbodyRef.value.offsetWidth > tbodyRef.value.clientWidth;
      }
      return false;
    };
    const handleTbodyResize = () => {
      const _hasScrollBar = isTbodyHasScrollBar();
      if (hasScrollBar.value !== _hasScrollBar) {
        hasScrollBar.value = _hasScrollBar;
      }
      setAlignPosition();
    };
    onMounted(() => {
      hasScrollBar.value = isTbodyHasScrollBar();
    });
    const spinProps = computed(() => isObject(props.loading) ? props.loading : {
      loading: props.loading
    });
    const renderEmpty = () => {
      return createVNode(Tr, {
        "isEmptyRow": true
      }, {
        default: () => [createVNode(Td, {
          "colSpan": dataColumns.value.length + operations.value.length
        }, {
          default: () => {
            var _a, _b;
            return [(_b = (_a = slots.empty) == null ? void 0 : _a.call(slots)) != null ? _b : createVNode(Empty, null, null)];
          }
        })]
      });
    };
    const renderExpandContent = (record) => {
      var _a;
      if (isFunction(record.expand)) {
        return record.expand();
      }
      if (record.expand) {
        return record.expand;
      }
      if (slots["expand-row"]) {
        return slots["expand-row"]({
          record
        });
      }
      if ((_a = props.expandable) == null ? void 0 : _a.expandedRowRender) {
        return props.expandable.expandedRowRender(record);
      }
      return void 0;
    };
    const tableSpan = computed(() => {
      const data = {};
      flattenData.value.forEach((record, rowIndex) => {
        dataColumns.value.forEach((column, columnIndex) => {
          var _a, _b;
          const {
            rowspan = 1,
            colspan = 1
          } = (_b = (_a = props.spanMethod) == null ? void 0 : _a.call(props, {
            record,
            column,
            rowIndex,
            columnIndex
          })) != null ? _b : {};
          if (rowspan > 1 || colspan > 1) {
            data[`${rowIndex}-${columnIndex}`] = [rowspan, colspan];
          }
        });
      });
      return data;
    });
    const removedCells = computed(() => {
      const data = [];
      for (const indexKey of Object.keys(tableSpan.value)) {
        const indexArray = indexKey.split("-").map((item) => Number(item));
        const span = tableSpan.value[indexKey];
        for (let i = 1; i < span[0]; i++) {
          data.push(`${indexArray[0] + i}-${indexArray[1]}`);
          for (let j = 1; j < span[1]; j++) {
            data.push(`${indexArray[0] + i}-${indexArray[1] + j}`);
          }
        }
        for (let i = 1; i < span[1]; i++) {
          data.push(`${indexArray[0]}-${indexArray[1] + i}`);
        }
      }
      return data;
    });
    const virtualListRef = ref();
    const renderVirtualListBody = () => {
      return createVNode(VirtualList, mergeProps({
        "ref": virtualListRef,
        "class": `${prefixCls}-body`
      }, props.virtualListProps, {
        "data": flattenData.value
      }), {
        item: ({
          item,
          index
        }) => renderRecord(item, index)
      });
    };
    const renderExpandBtn = (record) => {
      var _a, _b, _c, _d, _e;
      const currentKey = record[rowKey.value];
      const expanded = expandedRowKeys.value.includes(currentKey);
      return createVNode("button", {
        "type": "button",
        "class": `${prefixCls}-expand-btn`,
        "onClick": (ev) => handleExpand(currentKey)
      }, [(_e = (_d = (_a = slots["expand-icon"]) == null ? void 0 : _a.call(slots, {
        expanded,
        record
      })) != null ? _d : (_c = (_b = props.expandable) == null ? void 0 : _b.icon) == null ? void 0 : _c.call(_b, expanded, record)) != null ? _e : expanded ? createVNode(IconMinus, null, null) : createVNode(IconPlus, null, null)]);
    };
    const renderRecord = (record, rowIndex, {
      indentSize = 0
    } = {}) => {
      var _a, _b, _c, _d;
      const currentKey = record[rowKey.value];
      const expandContent = renderExpandContent(record);
      const showExpand = expandedRowKeys.value.includes(currentKey);
      const hasSubTree = Boolean(record.children ? props.hideExpandButtonOnEmpty ? record.children.length > 0 : true : props.loadMore && !record.isLeaf);
      const subTreeHasSubData = (_b = (_a = record.children) == null ? void 0 : _a.some((record2) => Boolean(record2.children))) != null ? _b : false;
      const scrollContainer = isScroll.value.y ? tbodyRef.value : containerRef.value;
      return createVNode(Fragment, null, [createVNode(Tr, {
        "key": currentKey,
        "checked": ((_c = selectedRowKeys.value) == null ? void 0 : _c.indexOf(currentKey)) > -1,
        "onClick": (e) => handleRowClick(record)
      }, {
        default: () => [operations.value.map((operation, index) => {
          var _a2, _b2, _c2;
          const style = isVirtualList.value && ((_a2 = thRefs.value.operation[index]) == null ? void 0 : _a2.offsetWidth) ? {
            width: `${(_b2 = thRefs.value.operation[index]) == null ? void 0 : _b2.offsetWidth}px`
          } : void 0;
          return createVNode(OperationTd, {
            "key": `operation-td-${index}`,
            "style": style,
            "record": record,
            "rowKey": rowKey.value,
            "isRadio": isRadio.value,
            "hasExpand": Boolean(expandContent),
            "operationColumn": operation,
            "operations": operations.value,
            "selectedRowKeys": selectedRowKeys.value,
            "expandedIcon": (_c2 = props.expandable) == null ? void 0 : _c2.icon,
            "expandedRowKeys": expandedRowKeys.value,
            "renderExpandBtn": renderExpandBtn,
            "onSelect": handleSelect,
            "onExpand": handleExpand
          }, null);
        }), dataColumns.value.map((column, index) => {
          var _a2, _b2, _c2;
          const extraProps = index === 0 ? {
            showExpandBtn: hasSubTree,
            indentSize: hasSubTree ? indentSize - 20 : indentSize
          } : {};
          const style = isVirtualList.value && ((_a2 = thRefs.value.data[column.dataIndex]) == null ? void 0 : _a2.offsetWidth) ? {
            width: `${(_b2 = thRefs.value.data[column.dataIndex]) == null ? void 0 : _b2.offsetWidth}px`
          } : void 0;
          const cellId = `${rowIndex}-${index}`;
          const [rowspan, colspan] = (_c2 = tableSpan.value[`${rowIndex}-${index}`]) != null ? _c2 : [1, 1];
          if (removedCells.value.includes(cellId)) {
            return null;
          }
          return createVNode(Td, mergeProps({
            "key": `td-${index}`,
            "style": style,
            "rowIndex": rowIndex,
            "record": record,
            "isSorted": Boolean(computedSorter.value.filed) && column.dataIndex === computedSorter.value.filed,
            "column": column,
            "operations": operations.value,
            "dataColumns": dataColumns.value,
            "loadMore": props.loadMore,
            "addLazyLoadData": addLazyLoadData,
            "rowSpan": rowspan,
            "renderExpandBtn": renderExpandBtn,
            "colSpan": colspan
          }, extraProps, {
            "onClick": (e) => handleCellClick(record, column)
          }), null);
        })]
      }), showExpand && (hasSubTree ? (_d = record.children) == null ? void 0 : _d.map((item, index) => renderRecord(item, index, {
        indentSize: subTreeHasSubData ? indentSize + props.indentSize + 20 : indentSize + props.indentSize
      })) : createVNode(Tr, {
        "isExpandRow": true,
        "key": `${currentKey}-expand`
      }, {
        default: () => [createVNode(Td, {
          "isFixedExpand": hasLeftFixedColumn.value || hasRightFixedColumn.value,
          "containerWidth": scrollContainer == null ? void 0 : scrollContainer.clientWidth,
          "colSpan": dataColumns.value.length + operations.value.length
        }, _isSlot(expandContent) ? expandContent : {
          default: () => [expandContent]
        })]
      }))]);
    };
    const renderBody = () => {
      const hasSubData = flattenData.value.some((record) => Boolean(record.children));
      return createVNode(Tbody, null, {
        default: () => [flattenData.value.length > 0 ? flattenData.value.map((record, index) => renderRecord(record, index, {
          indentSize: hasSubData ? 20 : 0
        })) : renderEmpty()]
      });
    };
    const renderHeader = () => {
      let _slot;
      return createVNode(Thead, null, _isSlot(_slot = groupColumns.value.map((row, index) => createVNode(Tr, {
        "key": `header-row-${index}`
      }, {
        default: () => [index === 0 && operations.value.map((operation, index2) => createVNode(OperationTh, {
          "ref": (ins) => {
            if (ins == null ? void 0 : ins.$el) {
              thRefs.value.operation[index2] = ins.$el;
            }
          },
          "key": `operation-th-${index2}`,
          "operationColumn": operation,
          "operations": operations.value,
          "rowSelection": props.rowSelection,
          "rowSpan": groupColumns.value.length,
          "expandable": props.expandable,
          "selectedNumber": currentSelectedRowKeys.value.length,
          "totalNumber": currentAllRowKeys.value.length,
          "totalEnabledNumber": currentAllEnabledRowKeys.value.length,
          "onSelectAll": handleSelectAll
        }, null)), row.map((column, index2) => {
          var _a;
          const sortOrder = column.dataIndex === computedSorter.value.filed ? computedSorter.value.direction : "";
          return createVNode(Th, {
            "key": `th-${index2}`,
            "ref": (ins) => {
              if (ins == null ? void 0 : ins.$el) {
                thRefs.value.data[column.dataIndex] = ins.$el;
              }
            },
            "column": column,
            "operations": operations.value,
            "dataColumns": dataColumns.value,
            "sortOrder": sortOrder,
            "filterIconAlignLeft": props.filterIconAlignLeft,
            "filterValue": (_a = computedFilters.value[column.dataIndex]) != null ? _a : [],
            "onSorterChange": handleSorterChange,
            "onFilterChange": handleFilterChange,
            "onClick": (e) => handleHeaderClick(column)
          }, null);
        })]
      }))) ? _slot : {
        default: () => [_slot]
      });
    };
    const renderContent = () => {
      if (isScroll.value.y || isVirtualList.value || isScroll.value.x && flattenData.value.length === 0) {
        const style = {
          overflowY: hasScrollBar.value ? "scroll" : "hidden"
        };
        return createVNode(Fragment, null, [props.showHeader && createVNode("div", {
          "ref": theadRef,
          "class": `${prefixCls}-header`,
          "style": style
        }, [createVNode("table", {
          "cellpadding": 0,
          "cellspacing": 0,
          "style": contentStyle.value
        }, [createVNode(ColGroup, {
          "dataColumns": dataColumns.value,
          "operations": operations.value
        }, null), renderHeader()])]), createVNode(ResizeObserver, {
          "onResize": handleTbodyResize
        }, {
          default: () => {
            var _a, _b, _c;
            return [isVirtualList.value ? renderVirtualListBody() : createVNode("div", {
              "ref": tbodyRef,
              "class": `${prefixCls}-body`,
              "style": {
                maxHeight: isNumber((_a = props.scroll) == null ? void 0 : _a.y) ? `${(_b = props.scroll) == null ? void 0 : _b.y}px` : (_c = props.scroll) == null ? void 0 : _c.y
              },
              "onScroll": handleScroll
            }, [createVNode("table", {
              "cellpadding": 0,
              "cellspacing": 0,
              "style": contentStyle.value
            }, [flattenData.value.length !== 0 && createVNode(ColGroup, {
              "dataColumns": dataColumns.value,
              "operations": operations.value
            }, null), renderBody()])])];
          }
        })]);
      }
      return createVNode(ResizeObserver, {
        "onResize": () => setAlignPosition()
      }, {
        default: () => [createVNode("table", {
          "cellpadding": 0,
          "cellspacing": 0,
          "style": contentStyle.value
        }, [createVNode(ColGroup, {
          "dataColumns": dataColumns.value,
          "operations": operations.value
        }, null), props.showHeader && renderHeader(), renderBody()])]
      });
    };
    const renderTable = (content) => createVNode(Fragment, null, [createVNode("div", {
      "ref": containerRef,
      "class": [`${prefixCls}-container`, tableCls.value],
      "onScroll": handleScroll
    }, [createVNode("div", {
      "class": `${prefixCls}-content`
    }, [content ? createVNode("table", {
      "cellpadding": 0,
      "cellspacing": 0
    }, [content()]) : renderContent()])]), slots.footer && createVNode("div", {
      "class": `${prefixCls}-footer`
    }, [slots.footer()])]);
    const renderPagination = () => {
      const paginationProps = isObject(props.pagination) ? omit(props.pagination, ["current", "pageSize", "defaultCurrent", "defaultPageSize"]) : {};
      return createVNode("div", {
        "class": paginationCls.value
      }, [createVNode(Pagination, mergeProps({
        "total": processedData.value.length,
        "current": page.value,
        "pageSize": pageSize.value,
        "onChange": (page2) => {
          handlePageChange(page2);
          handleChange("pagination");
        },
        "onPageSizeChange": (pageSize2) => {
          handlePageSizeChange(pageSize2);
          handleChange("pagination");
        }
      }, paginationProps), null)]);
    };
    return () => {
      if (slots.default) {
        return createVNode("div", {
          "class": cls.value
        }, [renderTable(slots.default)]);
      }
      return createVNode("div", {
        "class": cls.value
      }, [createVNode(Spin, spinProps.value, {
        default: () => [props.pagination !== false && isPaginationTop.value && renderPagination(), renderTable(), props.pagination !== false && !isPaginationTop.value && renderPagination()]
      })]);
    };
  }
});
export { _Table as default };
