import { defineComponent, inject, ref, reactive, computed, onMounted, watch, createVNode, mergeProps, TransitionGroup } from "vue";
import { getPrefixCls } from "../_utils/global-config.js";
import { INPUT_EVENTS } from "../_utils/constant.js";
import { Enter, Backspace } from "../_utils/keycode.js";
import { getValueData } from "./utils.js";
import Tag from "../tag/index.js";
import IconHover from "../_components/icon-hover.js";
import IconClose from "../icon/icon-close/index.js";
import { omit } from "../_utils/omit.js";
import pick from "../_utils/pick.js";
import ResizeObserver from "../_components/resize-observer.js";
import { configProviderInjectionKey } from "../config-provider/context.js";
var _InputTag = defineComponent({
  name: "InputTag",
  inheritAttrs: false,
  props: {
    modelValue: {
      type: Array
    },
    defaultValue: {
      type: Array,
      default: () => []
    },
    inputValue: String,
    defaultInputValue: {
      type: String,
      default: ""
    },
    placeholder: String,
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: () => {
        var _a, _b;
        return (_b = (_a = inject(configProviderInjectionKey, void 0)) == null ? void 0 : _a.size) != null ? _b : "medium";
      }
    },
    maxTagCount: {
      type: Number,
      default: 0
    },
    retainInputValue: {
      type: Boolean,
      default: false
    },
    formatTag: {
      type: Function
    },
    uniqueValue: {
      type: Boolean,
      default: false
    },
    baseCls: String,
    focused: Boolean,
    disabledInput: Boolean,
    onChange: {
      type: [Function, Array]
    },
    onInputValueChange: {
      type: [Function, Array]
    },
    onPressEnter: {
      type: [Function, Array]
    },
    onRemove: {
      type: [Function, Array]
    },
    onClear: {
      type: [Function, Array]
    },
    onFocus: {
      type: [Function, Array]
    },
    onBlur: {
      type: [Function, Array]
    }
  },
  emits: [
    "update:modelValue",
    "update:inputValue",
    "change",
    "inputValueChange",
    "pressEnter",
    "remove",
    "clear",
    "focus",
    "blur"
  ],
  setup(props, {
    emit,
    slots,
    attrs
  }) {
    const prefixCls = props.baseCls || getPrefixCls("input-tag");
    const inputRef = ref();
    const mirrorRef = ref();
    const _focused = ref(false);
    const _value = ref(props.defaultValue);
    const _inputValue = ref(props.defaultInputValue);
    const isComposition = ref(false);
    const compositionValue = ref("");
    const inputStyle = reactive({
      width: "12px"
    });
    const mergedFocused = computed(() => props.focused || _focused.value);
    const updateInputValue = (value) => {
      _inputValue.value = value;
      emit("update:inputValue", value);
    };
    const handleComposition = (e) => {
      var _a;
      const {
        value
      } = e.target;
      if (e.type === "compositionend") {
        isComposition.value = false;
        compositionValue.value = "";
        emit("inputValueChange", value, e);
        updateInputValue(value);
      } else {
        isComposition.value = true;
        compositionValue.value = computedInputValue.value + ((_a = e.data) != null ? _a : "");
      }
    };
    const computedValue = computed(() => {
      var _a;
      return (_a = props.modelValue) != null ? _a : _value.value;
    });
    const computedInputValue = computed(() => {
      var _a;
      return (_a = props.inputValue) != null ? _a : _inputValue.value;
    });
    const handleMousedown = (e) => {
      if (inputRef.value && e.target !== inputRef.value) {
        e.preventDefault();
        inputRef.value.focus();
      }
    };
    const handleInput = (e) => {
      const {
        value
      } = e.target;
      if (!isComposition.value) {
        emit("inputValueChange", value, e);
        updateInputValue(value);
      }
    };
    const tags = computed(() => {
      const valueData = getValueData(computedValue.value);
      if (props.maxTagCount > 0) {
        const invisibleTags = valueData.length - props.maxTagCount;
        if (invisibleTags > 0) {
          const result = valueData.slice(0, props.maxTagCount);
          result.push({
            value: "more",
            label: `+${invisibleTags}...`,
            closable: false
          });
          return result;
        }
      }
      return valueData;
    });
    const handleRemove = (value, index, e) => {
      var _a;
      const newValue = (_a = computedValue.value) == null ? void 0 : _a.filter((_, i) => i !== index);
      _value.value = newValue;
      emit("remove", value, e);
      emit("update:modelValue", newValue);
      emit("change", newValue, e);
    };
    const handleClear = (e) => {
      const newValue = [];
      _value.value = newValue;
      emit("clear", e);
      emit("update:modelValue", newValue);
      emit("change", newValue, e);
    };
    const showClearBtn = computed(() => !props.disabled && !props.readonly && props.allowClear && Boolean(computedValue.value.length));
    const handlePressEnter = (e) => {
      var _a;
      if (computedInputValue.value) {
        e.preventDefault();
        emit("pressEnter", computedInputValue.value, e);
        if (props.uniqueValue && ((_a = computedValue.value) == null ? void 0 : _a.includes(computedInputValue.value))) {
          return;
        }
        const newValue = computedValue.value.concat(computedInputValue.value);
        _value.value = newValue;
        emit("update:modelValue", newValue);
        emit("change", newValue, e);
        if (!props.retainInputValue) {
          _inputValue.value = "";
          emit("update:inputValue", "");
          emit("inputValueChange", "", e);
        }
      }
    };
    const handleFocus = (ev) => {
      _focused.value = true;
      emit("focus", ev);
    };
    const handleBlur = (ev) => {
      _focused.value = false;
      emit("blur", ev);
    };
    const handleKeyDown = (e) => {
      const keyCode = e.key || e.code;
      if (!isComposition.value && computedInputValue.value && keyCode === Enter.key) {
        handlePressEnter(e);
      }
      if (!isComposition.value && tags.value.length > 0 && !computedInputValue.value && keyCode === Backspace.key) {
        const lastIndex = tags.value.length - 1;
        handleRemove(tags.value[lastIndex].value, lastIndex, e);
      }
    };
    const setInputWidth = (width) => {
      if (width > 12) {
        inputStyle.width = `${width}px`;
      } else {
        inputStyle.width = "12px";
      }
    };
    onMounted(() => {
      if (mirrorRef.value) {
        setInputWidth(mirrorRef.value.offsetWidth);
      }
    });
    const handleResize = () => {
      if (mirrorRef.value) {
        setInputWidth(mirrorRef.value.offsetWidth);
      }
    };
    watch(computedInputValue, (value) => {
      if (inputRef.value && !isComposition.value && value !== inputRef.value.value) {
        inputRef.value.value = value;
      }
    });
    const cls = computed(() => [prefixCls, `${prefixCls}-size-${props.size}`, {
      [`${prefixCls}-disabled`]: props.disabled,
      [`${prefixCls}-disabled-input`]: props.disabledInput,
      [`${prefixCls}-error`]: props.error,
      [`${prefixCls}-focus`]: mergedFocused.value,
      [`${prefixCls}-readonly`]: props.readonly,
      [`${prefixCls}-has-tag`]: tags.value.length > 0,
      [`${prefixCls}-has-prefix`]: Boolean(slots.prefix),
      [`${prefixCls}-has-suffix`]: Boolean(slots.suffix) || showClearBtn.value,
      [`${prefixCls}-has-placeholder`]: !computedValue.value.length
    }]);
    const wrapperAttrs = computed(() => omit(attrs, INPUT_EVENTS));
    const inputAttrs = computed(() => pick(attrs, INPUT_EVENTS));
    const render = () => createVNode("span", mergeProps({
      "class": cls.value,
      "onMousedown": handleMousedown
    }, wrapperAttrs.value), [createVNode(ResizeObserver, {
      "onResize": handleResize
    }, {
      default: () => [createVNode("span", {
        "ref": mirrorRef,
        "class": `${prefixCls}-mirror`
      }, [tags.value.length > 0 ? compositionValue.value || computedInputValue.value : compositionValue.value || computedInputValue.value || props.placeholder])]
    }), slots.prefix && createVNode("span", {
      "class": `${prefixCls}-prefix`
    }, [slots.prefix()]), createVNode(TransitionGroup, {
      "tag": "span",
      "name": "input-tag-zoom",
      "class": `${prefixCls}-inner`
    }, {
      default: () => [tags.value.map((item, index) => createVNode(Tag, mergeProps({
        "key": `tag-${item.value}`,
        "class": `${prefixCls}-tag`,
        "closable": !props.disabled && !props.readonly && item.closable,
        "visible": true,
        "onClose": (ev) => handleRemove(item.value, index, ev)
      }, item.tagProps), {
        default: () => {
          var _a, _b, _c, _d;
          return [(_d = (_c = (_a = slots.tag) == null ? void 0 : _a.call(slots, {
            data: item
          })) != null ? _c : (_b = props.formatTag) == null ? void 0 : _b.call(props, item)) != null ? _d : item.label];
        }
      })), createVNode("input", mergeProps(inputAttrs.value, {
        "ref": inputRef,
        "key": "input-tag-input",
        "class": `${prefixCls}-input`,
        "style": inputStyle,
        "placeholder": tags.value.length === 0 ? props.placeholder : void 0,
        "disabled": props.disabled,
        "readonly": props.readonly || props.disabledInput,
        "onInput": handleInput,
        "onKeydown": handleKeyDown,
        "onFocus": handleFocus,
        "onBlur": handleBlur,
        "onCompositionstart": handleComposition,
        "onCompositionupdate": handleComposition,
        "onCompositionend": handleComposition
      }), null)]
    }), showClearBtn.value && createVNode(IconHover, {
      "class": `${prefixCls}-clear-btn`,
      "onClick": handleClear,
      "onMousedown": (e) => e.stopPropagation()
    }, {
      default: () => [createVNode(IconClose, null, null)]
    }), slots.suffix && createVNode("span", {
      "class": `${prefixCls}-suffix`
    }, [slots.suffix()])]);
    return {
      inputRef,
      render
    };
  },
  methods: {
    focus() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.focus();
    },
    blur() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.blur();
    }
  },
  render() {
    return this.render();
  }
});
export { _InputTag as default };
