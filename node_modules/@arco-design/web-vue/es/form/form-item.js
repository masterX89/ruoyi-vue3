var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
import { defineComponent, toRefs, inject, computed, reactive, ref, provide, nextTick, onMounted, onBeforeUnmount, createVNode, mergeProps } from "vue";
import { Schema } from "b-validate";
import { formKey, formItemKey } from "./context.js";
import "../grid/index.js";
import FormItemLabel from "./form-item-label.js";
import FormItemMessage from "./form-item-message.js";
import { getPrefixCls } from "../_utils/global-config.js";
import { getValueByPath } from "../_utils/get-value-by-path.js";
import { mergeFirstChild } from "../_utils/vue-utils.js";
import { getFinalValidateStatus, getFinalValidateMessage } from "./utils.js";
import { isFunction } from "../_utils/is.js";
import Row from "../grid/grid-row.js";
import Col from "../grid/grid-col.js";
var FormItem = defineComponent({
  name: "FormItem",
  components: {
    ArcoRow: Row,
    ArcoCol: Col,
    FormItemLabel,
    FormItemMessage
  },
  inheritAttrs: false,
  props: {
    field: {
      type: String,
      default: ""
    },
    label: String,
    showColon: {
      type: Boolean,
      default: false
    },
    noStyle: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    help: String,
    extra: String,
    required: {
      type: Boolean,
      default: false
    },
    rules: {
      type: [Object, Array]
    },
    validateStatus: {
      type: String
    },
    validateTrigger: {
      type: [String, Array],
      default: "change"
    },
    labelColProps: Object,
    wrapperColProps: Object,
    hideLabel: {
      type: Boolean,
      default: false
    },
    hideAsterisk: {
      type: Boolean,
      default: false
    },
    labelColStyle: Object,
    wrapperColStyle: Object,
    rowProps: Object,
    rowClass: [String, Array, Object],
    contentClass: [String, Array, Object],
    contentFlex: {
      type: Boolean,
      default: true
    },
    mergeProps: {
      type: [Boolean, Function],
      default: true
    },
    labelColFlex: {
      type: [Number, String]
    }
  },
  setup(props, {
    slots,
    attrs
  }) {
    const prefixCls = getPrefixCls("form-item");
    const {
      field
    } = toRefs(props);
    const formCtx = inject(formKey, void 0);
    const mergedLabelCol = computed(() => {
      var _a;
      const colProps = __spreadValues({}, (_a = props.labelColProps) != null ? _a : formCtx == null ? void 0 : formCtx.labelColProps);
      if (props.labelColFlex) {
        colProps.flex = props.labelColFlex;
      } else if (formCtx == null ? void 0 : formCtx.autoLabelWidth) {
        colProps.flex = `${formCtx == null ? void 0 : formCtx.maxLabelWidth}px`;
      }
      return colProps;
    });
    const mergedWrapperCol = computed(() => {
      var _a;
      const colProps = __spreadValues({}, (_a = props.wrapperColProps) != null ? _a : formCtx == null ? void 0 : formCtx.wrapperColProps);
      if (props.labelColFlex || (formCtx == null ? void 0 : formCtx.autoLabelWidth)) {
        colProps.flex = "auto";
      }
      return colProps;
    });
    const mergedLabelStyle = computed(() => {
      var _a;
      return (_a = props.labelColStyle) != null ? _a : formCtx == null ? void 0 : formCtx.labelColStyle;
    });
    const mergedWrapperStyle = computed(() => {
      var _a;
      return (_a = props.wrapperColStyle) != null ? _a : formCtx == null ? void 0 : formCtx.wrapperColStyle;
    });
    const initialValue = getValueByPath(formCtx == null ? void 0 : formCtx.model, props.field);
    const validateStatus = reactive({});
    const validateMessage = reactive({});
    const finalStatus = computed(() => getFinalValidateStatus(validateStatus));
    const finalMessage = computed(() => getFinalValidateMessage(validateMessage));
    const validateDisabled = ref(false);
    const fieldValue = computed(() => getValueByPath(formCtx == null ? void 0 : formCtx.model, props.field));
    const computedDisabled = computed(() => {
      var _a;
      return Boolean((_a = props.disabled) != null ? _a : formCtx == null ? void 0 : formCtx.disabled);
    });
    const computedValidateStatus = computed(() => {
      var _a;
      return (_a = props.validateStatus) != null ? _a : finalStatus.value;
    });
    const isError = computed(() => finalStatus.value === "error");
    const mergedRules = computed(() => {
      var _a, _b, _c;
      const baseRules = [].concat((_c = (_b = props.rules) != null ? _b : (_a = formCtx == null ? void 0 : formCtx.rules) == null ? void 0 : _a[props.field]) != null ? _c : []);
      const hasRequiredRule = baseRules.some((item) => item.required);
      if (props.required && !hasRequiredRule) {
        return [{
          required: true
        }].concat(baseRules);
      }
      return baseRules;
    });
    const isRequired = computed(() => mergedRules.value.some((item) => item.required));
    const formItemCtx = props.noStyle ? inject(formItemKey, void 0) : void 0;
    const updateValidateState = (field2, {
      status,
      message
    }) => {
      validateStatus[field2] = status;
      validateMessage[field2] = message;
      if (props.noStyle) {
        formItemCtx == null ? void 0 : formItemCtx.updateValidateState(field2, {
          status,
          message
        });
      }
    };
    provide(formItemKey, reactive({
      updateValidateState
    }));
    const validateField = () => {
      if (validateDisabled.value) {
        return Promise.resolve();
      }
      const rules = mergedRules.value;
      if (!field.value || rules.length === 0) {
        if (finalStatus.value) {
          clearValidate();
        }
        return Promise.resolve();
      }
      const _field = field.value;
      const _value = fieldValue.value;
      updateValidateState(_field, {
        status: "validating",
        message: ""
      });
      const schema = new Schema({
        [_field]: rules.map((rule) => {
          if (!rule.type && !rule.validator) {
            rule.type = "string";
          }
          return rule;
        })
      }, {
        ignoreEmptyString: true
      });
      return new Promise((resolve) => {
        schema.validate({
          [_field]: _value
        }, (err) => {
          var _a;
          const isError2 = Boolean(err == null ? void 0 : err[_field]);
          updateValidateState(_field, {
            status: isError2 ? "error" : "success",
            message: (_a = err == null ? void 0 : err[_field].message) != null ? _a : ""
          });
          const error = isError2 ? {
            field: field.value,
            value: err[_field].value,
            type: err[_field].type,
            isRequiredError: Boolean(err[_field].requiredError),
            message: err[_field].message
          } : void 0;
          resolve(error);
        });
      });
    };
    const validateTriggers = computed(() => [].concat(props.validateTrigger));
    const event = computed(() => validateTriggers.value.reduce((event2, trigger) => {
      switch (trigger) {
        case "change":
          event2.onChange = () => {
            validateField();
          };
          return event2;
        case "input":
          event2.onInput = () => {
            nextTick(() => {
              validateField();
            });
          };
          return event2;
        case "focus":
          event2.onFocus = () => {
            validateField();
          };
          return event2;
        case "blur":
          event2.onBlur = () => {
            validateField();
          };
          return event2;
        default:
          return event2;
      }
    }, {}));
    const clearValidate = () => {
      if (field.value) {
        updateValidateState(field.value, {
          status: "",
          message: ""
        });
      }
    };
    const setField = (data) => {
      var _a, _b;
      if (field.value) {
        validateDisabled.value = true;
        if ("value" in data && (formCtx == null ? void 0 : formCtx.model) && field.value in formCtx.model) {
          formCtx.model[field.value] = data.value;
        }
        if (data.status || data.message) {
          updateValidateState(field.value, {
            status: (_a = data.status) != null ? _a : "",
            message: (_b = data.message) != null ? _b : ""
          });
        }
        nextTick(() => {
          validateDisabled.value = false;
        });
      }
    };
    const resetField = () => {
      clearValidate();
      validateDisabled.value = true;
      if (formCtx == null ? void 0 : formCtx.model[field.value]) {
        formCtx.model[field.value] = initialValue;
      }
      nextTick(() => {
        validateDisabled.value = false;
      });
    };
    const formItemInfo = reactive({
      field,
      disabled: computedDisabled,
      error: isError,
      validate: validateField,
      clearValidate,
      resetField,
      setField
    });
    onMounted(() => {
      if (formItemInfo.field) {
        formCtx == null ? void 0 : formCtx.addField(formItemInfo);
      }
    });
    onBeforeUnmount(() => {
      if (formItemInfo.field) {
        formCtx == null ? void 0 : formCtx.removeField(formItemInfo);
      }
    });
    const cls = computed(() => [prefixCls, `${prefixCls}-layout-${formCtx == null ? void 0 : formCtx.layout}`, {
      [`${prefixCls}-error`]: isError.value,
      [`${prefixCls}-status-${computedValidateStatus.value}`]: Boolean(computedValidateStatus.value)
    }, props.rowClass]);
    const labelColCls = computed(() => [`${prefixCls}-label-col`, {
      [`${prefixCls}-label-col-left`]: (formCtx == null ? void 0 : formCtx.labelAlign) === "left",
      [`${prefixCls}-label-col-flex`]: (formCtx == null ? void 0 : formCtx.autoLabelWidth) || props.labelColFlex
    }]);
    const wrapperColCls = computed(() => [`${prefixCls}-wrapper-col`, {
      [`${prefixCls}-wrapper-col-flex`]: !mergedWrapperCol.value
    }]);
    return () => {
      var _a, _b, _c;
      const children = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : [];
      if (props.mergeProps) {
        mergeFirstChild(children, (vn) => {
          var _a2, _b2, _c2, _d, _e, _f;
          const extraProps = __spreadValues(__spreadProps(__spreadValues({}, attrs), {
            disabled: (_b2 = (_a2 = vn.props) == null ? void 0 : _a2.disabled) != null ? _b2 : computedDisabled.value,
            error: (_d = (_c2 = vn.props) == null ? void 0 : _c2.error) != null ? _d : isError.value,
            size: (_f = (_e = vn.props) == null ? void 0 : _e.size) != null ? _f : formCtx == null ? void 0 : formCtx.size
          }), event.value);
          return isFunction(props.mergeProps) ? props.mergeProps(extraProps) : extraProps;
        });
      }
      if (props.noStyle) {
        return children;
      }
      return createVNode(Row, mergeProps({
        "class": [...cls.value, {
          [`${prefixCls}-has-help`]: Boolean((_c = slots.help) != null ? _c : props.help)
        }],
        "wrap": !(props.labelColFlex || (formCtx == null ? void 0 : formCtx.autoLabelWidth)),
        "div": (formCtx == null ? void 0 : formCtx.layout) !== "horizontal" || props.hideLabel
      }, props.rowProps), {
        default: () => [!props.hideLabel && createVNode(Col, mergeProps({
          "class": labelColCls.value,
          "style": mergedLabelStyle.value
        }, mergedLabelCol.value), {
          default: () => [createVNode(FormItemLabel, {
            "required": props.hideAsterisk ? false : isRequired.value,
            "showColon": props.showColon
          }, {
            default: () => {
              var _a2, _b2;
              return [(_b2 = (_a2 = slots.label) == null ? void 0 : _a2.call(slots)) != null ? _b2 : props.label];
            }
          })]
        }), createVNode(Col, mergeProps({
          "class": wrapperColCls.value,
          "style": mergedWrapperStyle.value
        }, mergedWrapperCol.value), {
          default: () => {
            var _a2, _b2;
            return [createVNode("div", {
              "class": `${prefixCls}-content-wrapper`
            }, [createVNode("div", {
              "class": [`${prefixCls}-content`, {
                [`${prefixCls}-content-flex`]: props.contentFlex
              }, props.contentClass]
            }, [children])]), (isError.value || props.help || slots.help) && createVNode(FormItemMessage, {
              "error": finalMessage.value,
              "help": props.help
            }, {
              help: slots.help
            }), (props.extra || slots.extra) && createVNode("div", {
              "class": `${prefixCls}-extra`
            }, [(_b2 = (_a2 = slots.extra) == null ? void 0 : _a2.call(slots)) != null ? _b2 : props.extra])];
          }
        })]
      });
    };
  }
});
export { FormItem as default };
