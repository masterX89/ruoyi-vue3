"use strict";
var vue = require("vue");
var responsiveObserve = require("../_utils/responsive-observe.js");
var globalConfig = require("../_utils/global-config.js");
var context = require("./context.js");
var pluginVue_exportHelper = require("../_virtual/plugin-vue_export-helper");
const getGutter = (gutter, screens) => {
  let result = 0;
  if (typeof gutter === "object") {
    for (let i = 0; i < responsiveObserve.responsiveArray.length; i++) {
      const breakpoint = responsiveObserve.responsiveArray[i];
      if (screens[breakpoint] && gutter[breakpoint] !== void 0) {
        result = gutter[breakpoint];
        break;
      }
    }
  } else {
    result = gutter;
  }
  return result;
};
const _sfc_main = vue.defineComponent({
  name: "Row",
  props: {
    gutter: {
      type: [Number, Object, Array],
      default: 0
    },
    justify: {
      type: String,
      validator: (value) => {
        return [
          "start",
          "center",
          "end",
          "space-around",
          "space-between"
        ].includes(value);
      },
      default: "start"
    },
    align: {
      type: String,
      validator: (value) => {
        return ["start", "center", "end", "stretch"].includes(value);
      },
      default: "start"
    },
    div: {
      type: Boolean
    },
    wrap: {
      type: Boolean,
      default: true
    }
  },
  setup(props) {
    const { gutter, align, justify, div, wrap } = vue.toRefs(props);
    const prefixCls = globalConfig.getPrefixCls("row");
    const classNames = vue.computed(() => {
      return {
        [`${prefixCls}`]: !div.value,
        [`${prefixCls}-nowrap`]: !wrap.value,
        [`${prefixCls}-align-${align.value}`]: align.value,
        [`${prefixCls}-justify-${justify.value}`]: justify.value
      };
    });
    const state = vue.reactive({
      screens: {
        xs: true,
        sm: true,
        md: true,
        lg: true,
        xl: true,
        xxl: true
      }
    });
    const subscribeToken = responsiveObserve["default"].subscribe((screens) => {
      if (!Array.isArray(gutter.value) && typeof gutter.value === "object" || Array.isArray(gutter.value) && (typeof gutter.value[0] === "object" || typeof gutter.value[1] === "object")) {
        state.screens = screens;
      }
    });
    const gutterHorizontal = vue.computed(() => getGutter(Array.isArray(gutter.value) ? gutter.value[0] : gutter.value, state.screens));
    const gutterVertical = vue.computed(() => getGutter(Array.isArray(gutter.value) ? gutter.value[1] : 0, state.screens));
    const styles = vue.computed(() => {
      const result = {};
      if ((gutterHorizontal.value || gutterVertical.value) && !div.value) {
        const marginHorizontal = -gutterHorizontal.value / 2;
        const marginVertical = -gutterVertical.value / 2;
        if (marginHorizontal) {
          result.marginLeft = `${marginHorizontal}px`;
          result.marginRight = `${marginHorizontal}px`;
        }
        if (marginVertical) {
          result.marginTop = `${marginVertical}px`;
          result.marginBottom = `${marginVertical}px`;
        }
      }
      return result;
    });
    vue.onUnmounted(() => {
      responsiveObserve["default"].unsubscribe(subscribeToken);
    });
    const resultGutter = vue.computed(() => [
      gutterHorizontal.value,
      gutterVertical.value
    ]);
    vue.provide(context.RowContextInjectionKey, vue.reactive({
      gutter: resultGutter,
      div
    }));
    return {
      classNames,
      styles
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(_ctx.classNames),
    style: vue.normalizeStyle(_ctx.styles)
  }, [
    vue.renderSlot(_ctx.$slots, "default")
  ], 6);
}
var Row = /* @__PURE__ */ pluginVue_exportHelper(_sfc_main, [["render", _sfc_render]]);
module.exports = Row;
