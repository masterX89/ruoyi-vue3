"use strict";
var vue = require("vue");
var globalConfig = require("../_utils/global-config.js");
var constant = require("../_utils/constant.js");
var keycode = require("../_utils/keycode.js");
var utils = require("./utils.js");
var index = require("../tag/index.js");
var iconHover = require("../_components/icon-hover.js");
var index$1 = require("../icon/icon-close/index.js");
var omit = require("../_utils/omit.js");
var pick = require("../_utils/pick.js");
var resizeObserver = require("../_components/resize-observer.js");
var context = require("../config-provider/context.js");
var _InputTag = vue.defineComponent({
  name: "InputTag",
  inheritAttrs: false,
  props: {
    modelValue: {
      type: Array
    },
    defaultValue: {
      type: Array,
      default: () => []
    },
    inputValue: String,
    defaultInputValue: {
      type: String,
      default: ""
    },
    placeholder: String,
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: () => {
        var _a, _b;
        return (_b = (_a = vue.inject(context.configProviderInjectionKey, void 0)) == null ? void 0 : _a.size) != null ? _b : "medium";
      }
    },
    maxTagCount: {
      type: Number,
      default: 0
    },
    retainInputValue: {
      type: Boolean,
      default: false
    },
    formatTag: {
      type: Function
    },
    uniqueValue: {
      type: Boolean,
      default: false
    },
    baseCls: String,
    focused: Boolean,
    disabledInput: Boolean,
    onChange: {
      type: [Function, Array]
    },
    onInputValueChange: {
      type: [Function, Array]
    },
    onPressEnter: {
      type: [Function, Array]
    },
    onRemove: {
      type: [Function, Array]
    },
    onClear: {
      type: [Function, Array]
    },
    onFocus: {
      type: [Function, Array]
    },
    onBlur: {
      type: [Function, Array]
    }
  },
  emits: [
    "update:modelValue",
    "update:inputValue",
    "change",
    "inputValueChange",
    "pressEnter",
    "remove",
    "clear",
    "focus",
    "blur"
  ],
  setup(props, {
    emit,
    slots,
    attrs
  }) {
    const prefixCls = props.baseCls || globalConfig.getPrefixCls("input-tag");
    const inputRef = vue.ref();
    const mirrorRef = vue.ref();
    const _focused = vue.ref(false);
    const _value = vue.ref(props.defaultValue);
    const _inputValue = vue.ref(props.defaultInputValue);
    const isComposition = vue.ref(false);
    const compositionValue = vue.ref("");
    const inputStyle = vue.reactive({
      width: "12px"
    });
    const mergedFocused = vue.computed(() => props.focused || _focused.value);
    const updateInputValue = (value) => {
      _inputValue.value = value;
      emit("update:inputValue", value);
    };
    const handleComposition = (e) => {
      var _a;
      const {
        value
      } = e.target;
      if (e.type === "compositionend") {
        isComposition.value = false;
        compositionValue.value = "";
        emit("inputValueChange", value, e);
        updateInputValue(value);
      } else {
        isComposition.value = true;
        compositionValue.value = computedInputValue.value + ((_a = e.data) != null ? _a : "");
      }
    };
    const computedValue = vue.computed(() => {
      var _a;
      return (_a = props.modelValue) != null ? _a : _value.value;
    });
    const computedInputValue = vue.computed(() => {
      var _a;
      return (_a = props.inputValue) != null ? _a : _inputValue.value;
    });
    const handleMousedown = (e) => {
      if (inputRef.value && e.target !== inputRef.value) {
        e.preventDefault();
        inputRef.value.focus();
      }
    };
    const handleInput = (e) => {
      const {
        value
      } = e.target;
      if (!isComposition.value) {
        emit("inputValueChange", value, e);
        updateInputValue(value);
      }
    };
    const tags = vue.computed(() => {
      const valueData = utils.getValueData(computedValue.value);
      if (props.maxTagCount > 0) {
        const invisibleTags = valueData.length - props.maxTagCount;
        if (invisibleTags > 0) {
          const result = valueData.slice(0, props.maxTagCount);
          result.push({
            value: "more",
            label: `+${invisibleTags}...`,
            closable: false
          });
          return result;
        }
      }
      return valueData;
    });
    const handleRemove = (value, index2, e) => {
      var _a;
      const newValue = (_a = computedValue.value) == null ? void 0 : _a.filter((_, i) => i !== index2);
      _value.value = newValue;
      emit("remove", value, e);
      emit("update:modelValue", newValue);
      emit("change", newValue, e);
    };
    const handleClear = (e) => {
      const newValue = [];
      _value.value = newValue;
      emit("clear", e);
      emit("update:modelValue", newValue);
      emit("change", newValue, e);
    };
    const showClearBtn = vue.computed(() => !props.disabled && !props.readonly && props.allowClear && Boolean(computedValue.value.length));
    const handlePressEnter = (e) => {
      var _a;
      if (computedInputValue.value) {
        e.preventDefault();
        emit("pressEnter", computedInputValue.value, e);
        if (props.uniqueValue && ((_a = computedValue.value) == null ? void 0 : _a.includes(computedInputValue.value))) {
          return;
        }
        const newValue = computedValue.value.concat(computedInputValue.value);
        _value.value = newValue;
        emit("update:modelValue", newValue);
        emit("change", newValue, e);
        if (!props.retainInputValue) {
          _inputValue.value = "";
          emit("update:inputValue", "");
          emit("inputValueChange", "", e);
        }
      }
    };
    const handleFocus = (ev) => {
      _focused.value = true;
      emit("focus", ev);
    };
    const handleBlur = (ev) => {
      _focused.value = false;
      emit("blur", ev);
    };
    const handleKeyDown = (e) => {
      const keyCode = e.key || e.code;
      if (!isComposition.value && computedInputValue.value && keyCode === keycode.Enter.key) {
        handlePressEnter(e);
      }
      if (!isComposition.value && tags.value.length > 0 && !computedInputValue.value && keyCode === keycode.Backspace.key) {
        const lastIndex = tags.value.length - 1;
        handleRemove(tags.value[lastIndex].value, lastIndex, e);
      }
    };
    const setInputWidth = (width) => {
      if (width > 12) {
        inputStyle.width = `${width}px`;
      } else {
        inputStyle.width = "12px";
      }
    };
    vue.onMounted(() => {
      if (mirrorRef.value) {
        setInputWidth(mirrorRef.value.offsetWidth);
      }
    });
    const handleResize = () => {
      if (mirrorRef.value) {
        setInputWidth(mirrorRef.value.offsetWidth);
      }
    };
    vue.watch(computedInputValue, (value) => {
      if (inputRef.value && !isComposition.value && value !== inputRef.value.value) {
        inputRef.value.value = value;
      }
    });
    const cls = vue.computed(() => [prefixCls, `${prefixCls}-size-${props.size}`, {
      [`${prefixCls}-disabled`]: props.disabled,
      [`${prefixCls}-disabled-input`]: props.disabledInput,
      [`${prefixCls}-error`]: props.error,
      [`${prefixCls}-focus`]: mergedFocused.value,
      [`${prefixCls}-readonly`]: props.readonly,
      [`${prefixCls}-has-tag`]: tags.value.length > 0,
      [`${prefixCls}-has-prefix`]: Boolean(slots.prefix),
      [`${prefixCls}-has-suffix`]: Boolean(slots.suffix) || showClearBtn.value,
      [`${prefixCls}-has-placeholder`]: !computedValue.value.length
    }]);
    const wrapperAttrs = vue.computed(() => omit.omit(attrs, constant.INPUT_EVENTS));
    const inputAttrs = vue.computed(() => pick(attrs, constant.INPUT_EVENTS));
    const render = () => vue.createVNode("span", vue.mergeProps({
      "class": cls.value,
      "onMousedown": handleMousedown
    }, wrapperAttrs.value), [vue.createVNode(resizeObserver, {
      "onResize": handleResize
    }, {
      default: () => [vue.createVNode("span", {
        "ref": mirrorRef,
        "class": `${prefixCls}-mirror`
      }, [tags.value.length > 0 ? compositionValue.value || computedInputValue.value : compositionValue.value || computedInputValue.value || props.placeholder])]
    }), slots.prefix && vue.createVNode("span", {
      "class": `${prefixCls}-prefix`
    }, [slots.prefix()]), vue.createVNode(vue.TransitionGroup, {
      "tag": "span",
      "name": "input-tag-zoom",
      "class": `${prefixCls}-inner`
    }, {
      default: () => [tags.value.map((item, index$12) => vue.createVNode(index, vue.mergeProps({
        "key": `tag-${item.value}`,
        "class": `${prefixCls}-tag`,
        "closable": !props.disabled && !props.readonly && item.closable,
        "visible": true,
        "onClose": (ev) => handleRemove(item.value, index$12, ev)
      }, item.tagProps), {
        default: () => {
          var _a, _b, _c, _d;
          return [(_d = (_c = (_a = slots.tag) == null ? void 0 : _a.call(slots, {
            data: item
          })) != null ? _c : (_b = props.formatTag) == null ? void 0 : _b.call(props, item)) != null ? _d : item.label];
        }
      })), vue.createVNode("input", vue.mergeProps(inputAttrs.value, {
        "ref": inputRef,
        "key": "input-tag-input",
        "class": `${prefixCls}-input`,
        "style": inputStyle,
        "placeholder": tags.value.length === 0 ? props.placeholder : void 0,
        "disabled": props.disabled,
        "readonly": props.readonly || props.disabledInput,
        "onInput": handleInput,
        "onKeydown": handleKeyDown,
        "onFocus": handleFocus,
        "onBlur": handleBlur,
        "onCompositionstart": handleComposition,
        "onCompositionupdate": handleComposition,
        "onCompositionend": handleComposition
      }), null)]
    }), showClearBtn.value && vue.createVNode(iconHover, {
      "class": `${prefixCls}-clear-btn`,
      "onClick": handleClear,
      "onMousedown": (e) => e.stopPropagation()
    }, {
      default: () => [vue.createVNode(index$1, null, null)]
    }), slots.suffix && vue.createVNode("span", {
      "class": `${prefixCls}-suffix`
    }, [slots.suffix()])]);
    return {
      inputRef,
      render
    };
  },
  methods: {
    focus() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.focus();
    },
    blur() {
      var _a;
      (_a = this.inputRef) == null ? void 0 : _a.blur();
    }
  },
  render() {
    return this.render();
  }
});
module.exports = _InputTag;
