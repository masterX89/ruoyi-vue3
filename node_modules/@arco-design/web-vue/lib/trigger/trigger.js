"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var vue = require("vue");
var globalConfig = require("../_utils/global-config.js");
var constant = require("../_utils/constant.js");
var utils = require("./utils.js");
var resizeObserver = require("../_components/resize-observer.js");
var dom = require("../_utils/dom.js");
var vueUtils = require("../_utils/vue-utils.js");
var usePickSlots = require("../_hooks/use-pick-slots.js");
var context = require("./context.js");
var throttleByRaf = require("../_utils/throttle-by-raf.js");
var usePopupManager = require("../_hooks/use-popup-manager.js");
var useResizeObserver = require("../_hooks/use-resize-observer.js");
function _isSlot(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !vue.isVNode(s);
}
var _Trigger = vue.defineComponent({
  name: "Trigger",
  inheritAttrs: false,
  props: {
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    trigger: {
      type: [String, Array],
      default: "hover",
      validator: (value) => {
        const values = [].concat(value);
        for (const value2 of values) {
          if (!constant.TRIGGER_EVENTS.includes(value2)) {
            return false;
          }
        }
        return true;
      }
    },
    position: {
      type: String,
      default: "bottom"
    },
    disabled: {
      type: Boolean,
      default: false
    },
    popupOffset: {
      type: Number,
      default: 0
    },
    popupTranslate: {
      type: [Array, Object]
    },
    showArrow: {
      type: Boolean,
      default: false
    },
    alignPoint: {
      type: Boolean,
      default: false
    },
    popupHoverStay: {
      type: Boolean,
      default: true
    },
    blurToClose: {
      type: Boolean,
      default: true
    },
    clickToClose: {
      type: Boolean,
      default: true
    },
    clickOutsideToClose: {
      type: Boolean,
      default: true
    },
    unmountOnClose: {
      type: Boolean,
      default: true
    },
    contentClass: {
      type: [String, Array, Object]
    },
    contentStyle: {
      type: Object
    },
    arrowClass: {
      type: [String, Array, Object]
    },
    arrowStyle: {
      type: Object
    },
    popupStyle: {
      type: Object
    },
    animationName: {
      type: String,
      default: "fade-in"
    },
    duration: {
      type: [Number, Object]
    },
    mouseEnterDelay: {
      type: Number,
      default: 100
    },
    mouseLeaveDelay: {
      type: Number,
      default: 100
    },
    focusDelay: {
      type: Number,
      default: 0
    },
    autoFitPopupWidth: {
      type: Boolean,
      default: false
    },
    autoFitPopupMinWidth: {
      type: Boolean,
      default: false
    },
    autoFixPosition: {
      type: Boolean,
      default: true
    },
    popupContainer: {
      type: [String, Object]
    },
    updateAtScroll: {
      type: Boolean,
      default: false
    },
    autoFitTransformOrigin: {
      type: Boolean,
      default: false
    },
    hideEmpty: {
      type: Boolean,
      default: false
    },
    openedCls: {
      type: String
    },
    autoFitPosition: {
      type: Boolean,
      default: true
    },
    renderToBody: {
      type: Boolean,
      default: true
    },
    preventFocus: {
      type: Boolean,
      default: false
    },
    onPopupVisibleChange: {
      type: [Function, Array]
    }
  },
  emits: [
    "update:popupVisible",
    "popupVisibleChange"
  ],
  setup(props, {
    emit,
    slots,
    attrs
  }) {
    const prefixCls = globalConfig.getPrefixCls("trigger");
    const triggerMethods = vue.computed(() => [].concat(props.trigger));
    const childrenRefs = new Set();
    const triggerCtx = vue.inject(context.triggerInjectionKey, void 0);
    const triggerRef = vue.ref();
    const triggerEle = vue.computed(() => vueUtils.isComponentInstance(triggerRef.value) ? triggerRef.value.$el : triggerRef.value);
    const popupRef = vue.ref();
    const popupVisible = vue.ref(props.defaultPopupVisible);
    const popupPosition = vue.ref(props.position);
    const popupStyle = vue.ref({});
    const arrowStyle = vue.ref({});
    const containerEle = vue.ref();
    const arrowRef = vue.ref();
    const mousePosition = vue.ref({
      top: 0,
      left: 0
    });
    const computedVisible = vue.computed(() => {
      var _a;
      return (_a = props.popupVisible) != null ? _a : popupVisible.value;
    });
    const {
      zIndex
    } = usePopupManager({
      visible: computedVisible
    });
    let delayTimer = 0;
    let outsideListener = false;
    const cleanDelayTimer = () => {
      if (delayTimer) {
        window.clearTimeout(delayTimer);
        delayTimer = 0;
      }
    };
    const updateMousePosition = (e) => {
      if (props.alignPoint) {
        const {
          pageX,
          pageY
        } = e;
        mousePosition.value = {
          top: pageY,
          left: pageX
        };
      }
    };
    const updatePopupStyle = () => {
      if (!triggerEle.value || !popupRef.value || !containerEle.value) {
        return;
      }
      const containerRect = containerEle.value.getBoundingClientRect();
      const triggerRect = props.alignPoint ? {
        top: mousePosition.value.top,
        bottom: mousePosition.value.top,
        left: mousePosition.value.left,
        right: mousePosition.value.left,
        scrollTop: mousePosition.value.top,
        scrollBottom: mousePosition.value.top,
        scrollLeft: mousePosition.value.left,
        scrollRight: mousePosition.value.left,
        width: 0,
        height: 0
      } : utils.getElementScrollRect(triggerEle.value, containerRect);
      const popupRect = utils.getElementScrollRect(popupRef.value, containerRect);
      const {
        style,
        position
      } = utils.getPopupStyle(props.position, containerRect, triggerRect, popupRect, {
        offset: props.popupOffset,
        translate: props.popupTranslate,
        customStyle: props.popupStyle,
        autoFitPosition: props.autoFitPosition,
        autoFitTransformOrigin: props.autoFitTransformOrigin
      });
      if (props.autoFitPopupMinWidth) {
        style.minWidth = `${triggerRect.width}px`;
      } else if (props.autoFitPopupWidth) {
        style.width = `${triggerRect.width}px`;
      }
      if (popupPosition.value !== position) {
        popupPosition.value = position;
      }
      popupStyle.value = style;
      if (props.showArrow) {
        arrowStyle.value = utils.getArrowStyle(position, triggerRect, popupRect, {
          customStyle: props.arrowStyle
        });
      }
    };
    const changeVisible = (visible, delay) => {
      if (visible === computedVisible.value && delayTimer === 0) {
        return;
      }
      const update = () => {
        popupVisible.value = visible;
        emit("update:popupVisible", visible);
        emit("popupVisibleChange", visible);
        if (visible) {
          vue.nextTick(() => {
            updatePopupStyle();
          });
        }
      };
      if (delay) {
        cleanDelayTimer();
        if (visible !== computedVisible.value) {
          delayTimer = window.setTimeout(update, delay);
        }
      } else {
        update();
      }
    };
    const handleClick = (e) => {
      if (props.disabled || !triggerMethods.value.includes("click") || computedVisible.value && !props.clickToClose) {
        return;
      }
      updateMousePosition(e);
      changeVisible(!computedVisible.value);
    };
    const handleMouseEnter = (e) => {
      if (props.disabled || !triggerMethods.value.includes("hover")) {
        return;
      }
      updateMousePosition(e);
      changeVisible(true, props.mouseEnterDelay);
    };
    const handleMouseEnterWithContext = (e) => {
      triggerCtx == null ? void 0 : triggerCtx.onMouseenter(e);
      handleMouseEnter(e);
    };
    const handleMouseLeave = (e) => {
      if (props.disabled || !triggerMethods.value.includes("hover")) {
        return;
      }
      changeVisible(false, props.mouseLeaveDelay);
    };
    const handleMouseLeaveWithContext = (e) => {
      triggerCtx == null ? void 0 : triggerCtx.onMouseleave(e);
      handleMouseLeave();
    };
    const handleFocusin = (e) => {
      if (props.disabled || !triggerMethods.value.includes("focus")) {
        return;
      }
      changeVisible(true, props.focusDelay);
    };
    const handleFocusout = (e) => {
      if (props.disabled || !triggerMethods.value.includes("focus")) {
        return;
      }
      if (!props.blurToClose) {
        return;
      }
      changeVisible(false);
    };
    const handleContextmenu = (e) => {
      e.preventDefault();
      if (props.disabled || !triggerMethods.value.includes("contextMenu") || computedVisible.value && !props.clickToClose) {
        return;
      }
      updateMousePosition(e);
      changeVisible(!computedVisible.value);
    };
    const addChildRef = (ref) => {
      childrenRefs.add(ref);
      triggerCtx == null ? void 0 : triggerCtx.addChildRef(ref);
    };
    const removeChildRef = (ref) => {
      childrenRefs.delete(ref);
      triggerCtx == null ? void 0 : triggerCtx.removeChildRef(ref);
    };
    vue.provide(context.triggerInjectionKey, vue.reactive({
      onMouseenter: handleMouseEnterWithContext,
      onMouseleave: handleMouseLeaveWithContext,
      addChildRef,
      removeChildRef
    }));
    const removeOutsideListener = () => {
      dom.off(document.documentElement, "mousedown", handleOutsideClick);
      outsideListener = false;
    };
    const contentSlot = usePickSlots(slots, "content");
    const hidePopup = vue.computed(() => {
      var _a;
      return props.hideEmpty && vueUtils.isEmptyChildren((_a = contentSlot.value) == null ? void 0 : _a.call(contentSlot));
    });
    const handleOutsideClick = (e) => {
      var _a, _b, _c;
      if (((_a = triggerEle.value) == null ? void 0 : _a.contains(e.target)) || ((_b = popupRef.value) == null ? void 0 : _b.contains(e.target))) {
        return;
      }
      for (const item of childrenRefs) {
        if ((_c = item.value) == null ? void 0 : _c.contains(e.target)) {
          return;
        }
      }
      removeOutsideListener();
      changeVisible(false);
    };
    const handleScroll = throttleByRaf.throttleByRaf(() => {
      if (computedVisible.value) {
        updatePopupStyle();
      }
    });
    const handleResize = () => {
      if (computedVisible.value) {
        updatePopupStyle();
      }
    };
    const handlePopupMouseDown = (e) => {
      if (props.preventFocus) {
        e.preventDefault();
      }
    };
    triggerCtx == null ? void 0 : triggerCtx.addChildRef(popupRef);
    const triggerCls = vue.computed(() => {
      return computedVisible.value ? props.openedCls : void 0;
    });
    let scrollElements;
    vue.watch(computedVisible, (value) => {
      if (props.clickOutsideToClose) {
        if (outsideListener && !value) {
          removeOutsideListener();
          return;
        }
        if (!outsideListener) {
          dom.on(document.documentElement, "mousedown", handleOutsideClick);
          outsideListener = true;
        }
      }
      if (props.updateAtScroll) {
        if (value) {
          scrollElements = utils.getScrollElements(triggerEle.value);
          for (const item of scrollElements) {
            item.addEventListener("scroll", handleScroll);
          }
        } else if (scrollElements) {
          for (const item of scrollElements) {
            item.removeEventListener("scroll", handleScroll);
          }
        }
      }
    });
    vue.watch(() => [props.autoFitPopupWidth, props.autoFitPopupMinWidth], () => {
      if (computedVisible.value) {
        updatePopupStyle();
      }
    });
    const {
      createResizeObserver,
      destroyResizeObserver
    } = useResizeObserver.useResizeObserver({
      elementRef: containerEle,
      onResize: handleResize
    });
    vue.onMounted(() => {
      if (props.popupContainer) {
        containerEle.value = dom.getElement(props.popupContainer);
      } else {
        containerEle.value = document.documentElement;
      }
      createResizeObserver();
      if (computedVisible.value) {
        updatePopupStyle();
      }
    });
    vue.onUpdated(() => {
      if (computedVisible.value) {
        updatePopupStyle();
      }
    });
    vue.onBeforeUnmount(() => {
      triggerCtx == null ? void 0 : triggerCtx.removeChildRef(popupRef);
      destroyResizeObserver();
    });
    return () => {
      var _a, _b, _c;
      const children = (_b = (_a = slots.default) == null ? void 0 : _a.call(slots)) != null ? _b : [];
      vueUtils.mergeFirstChild(children, {
        ref: triggerRef,
        class: triggerCls.value,
        onClick: handleClick,
        onMouseenter: handleMouseEnter,
        onMouseleave: handleMouseLeave,
        onFocusin: handleFocusin,
        onFocusout: handleFocusout,
        onContextmenu: handleContextmenu
      });
      return vue.createVNode(vue.Fragment, null, [props.autoFixPosition ? vue.createVNode(resizeObserver, {
        "onResize": handleResize
      }, _isSlot(children) ? children : {
        default: () => [children]
      }) : children, vue.createVNode(vue.Teleport, {
        "to": (_c = props.popupContainer) != null ? _c : "body",
        "disabled": !props.renderToBody
      }, {
        default: () => [vue.createVNode(vue.Transition, {
          "name": props.animationName,
          "duration": props.duration
        }, {
          default: () => [(!props.unmountOnClose || computedVisible.value) && !hidePopup.value && vue.createVNode(resizeObserver, {
            "onResize": handleResize
          }, {
            default: () => {
              var _a2;
              return [vue.withDirectives(vue.createVNode("div", vue.mergeProps({
                "ref": popupRef,
                "class": [`${prefixCls}-popup`, `${prefixCls}-position-${popupPosition.value}`],
                "style": __spreadProps(__spreadValues({}, popupStyle.value), {
                  zIndex: zIndex.value
                }),
                "trigger-placement": popupPosition.value,
                "onMouseenter": handleMouseEnterWithContext,
                "onMouseleave": handleMouseLeaveWithContext,
                "onMousedown": handlePopupMouseDown
              }, attrs), [vue.createVNode("div", {
                "class": [`${prefixCls}-content`, props.contentClass],
                "style": props.contentStyle
              }, [(_a2 = slots.content) == null ? void 0 : _a2.call(slots)]), props.showArrow && vue.createVNode("div", {
                "ref": arrowRef,
                "class": [`${prefixCls}-arrow`, props.arrowClass],
                "style": arrowStyle.value
              }, null)]), [[vue.vShow, computedVisible.value]])];
            }
          })]
        })]
      })]);
    };
  }
});
module.exports = _Trigger;
