"use strict";
var vue = require("vue");
var is = require("../../_utils/is.js");
var raf = require("../../_utils/raf.js");
var usePickSlots = require("../../_hooks/use-pick-slots.js");
var resizeObserver = require("../resize-observer.js");
var renderFunction = require("../render-function.js");
var filler = require("./filler.js");
var useViewportHeight = require("./hooks/use-viewport-height.js");
var useItemHeight = require("./hooks/use-item-height.js");
var useRenderChildren = require("./hooks/use-render-children.js");
var useRangeState = require("./hooks/use-range-state.js");
var useScrollTo = require("./hooks/use-scroll-to.js");
var index = require("./utils/index.js");
var _sfc_main = vue.defineComponent({
  name: "VirtualList",
  components: {
    ResizeOberver: resizeObserver,
    Filler: filler,
    RenderFunction: renderFunction
  },
  inheritAttrs: false,
  props: {
    height: {
      type: [Number, String],
      default: 200
    },
    threshold: {
      type: [Number, Object]
    },
    isStaticItemHeight: {
      type: Boolean
    },
    estimatedItemHeight: {
      type: Number
    },
    data: {
      type: Array,
      default: () => []
    },
    itemKey: {
      type: [String, Function],
      default: "key"
    },
    component: {
      type: String,
      default: "div"
    }
  },
  emits: ["scroll"],
  setup(props, {
    slots,
    emit
  }) {
    const {
      height,
      itemKey,
      data,
      estimatedItemHeight: propEstimatedItemHeight,
      isStaticItemHeight,
      threshold
    } = vue.toRefs(props);
    function getItemKey(item, index2) {
      return itemKey && itemKey.value ? is.isString(itemKey.value) ? item[itemKey.value] : itemKey.value(item) : index2;
    }
    const internalData = vue.computed(() => data.value.map((item, index2) => ({
      key: getItemKey(item, index2),
      index: index2,
      item
    })));
    const viewportRef = vue.ref();
    const {
      viewportHeight,
      setViewportHeight,
      needMeasureViewportHeight
    } = useViewportHeight.useViewportHeight(vue.reactive({
      height
    }));
    const {
      itemHeight,
      estimatedItemHeight,
      totalHeight,
      setItemHeight,
      getItemHeight,
      getItemHeightOrDefault,
      getItemHeightOrDefaultByIndex
    } = useItemHeight.useItemHeight(vue.reactive({
      estimatedItemHeight: propEstimatedItemHeight,
      data: internalData
    }));
    const itemCount = vue.computed(() => data.value.length);
    const visibleCount = vue.computed(() => Math.ceil(viewportHeight.value / itemHeight.value));
    const scrollTop = vue.ref(0);
    const startOffset = vue.ref(0);
    const {
      rangeState,
      updateRangeState
    } = useRangeState.useRangeState(vue.reactive({
      viewportRef,
      itemCount,
      visibleCount
    }));
    const visibleData = vue.computed(() => internalData.value.slice(rangeState.startIndex, Math.min(rangeState.endIndex + 1, itemCount.value)));
    const isVirtual = vue.computed(() => (threshold == null ? void 0 : threshold.value) !== null && ((threshold == null ? void 0 : threshold.value) === void 0 || itemCount.value >= threshold.value) && totalHeight.value > viewportHeight.value);
    const scrollListPadding = vue.computed(() => {
      if (!is.isUndefined(viewportRef.value)) {
        const viewport = viewportRef.value;
        const getPadding = (property) => +window.getComputedStyle(viewport)[property].replace(/\D/g, "");
        return {
          top: getPadding("paddingTop"),
          bottom: getPadding("paddingBottom")
        };
      }
      return {
        top: 0,
        bottom: 0
      };
    });
    const itemRender = usePickSlots(slots, "item");
    const renderChildren = useRenderChildren.useRenderChildren(vue.reactive({
      internalData,
      visibleData,
      itemRender,
      itemRef: (el, key) => {
        const itemHeight2 = getItemHeight(key);
        if (el && is.isUndefined(itemHeight2)) {
          if (isStaticItemHeight.value && !is.isUndefined(estimatedItemHeight.value)) {
            setItemHeight(key, estimatedItemHeight.value);
          } else {
            vue.nextTick(() => {
              setItemHeight(key, el.clientHeight);
            });
          }
        }
      }
    }));
    const updateScrollOffset = () => {
      if (!viewportRef.value || !isVirtual.value)
        return;
      const {
        scrollTop: scrollTop2,
        clientHeight,
        scrollHeight
      } = viewportRef.value;
      const scrollPtg = index.getScrollPercentage({
        scrollTop: scrollTop2,
        clientHeight,
        scrollHeight
      });
      let newStartOffset = index.getItemAbsoluteTop({
        scrollPtg,
        clientHeight,
        scrollTop: scrollTop2 - (scrollListPadding.value.top + scrollListPadding.value.bottom) * scrollPtg,
        itemHeight: getItemHeightOrDefaultByIndex(rangeState.itemIndex),
        itemOffsetPtg: rangeState.itemOffsetPtg
      });
      for (let index2 = rangeState.itemIndex - 1; index2 >= rangeState.startIndex; index2--) {
        newStartOffset -= getItemHeightOrDefaultByIndex(index2);
      }
      startOffset.value = newStartOffset;
    };
    const rafIdRef = vue.ref();
    vue.onUnmounted(() => {
      rafIdRef.value && raf.caf(rafIdRef.value);
    });
    const lockScrollRef = vue.ref(false);
    const {
      fixScrollTo,
      prepareScrollTo
    } = useScrollTo.useScrollTo(vue.reactive({
      isVirtual,
      isStaticItemHeight,
      rangeState,
      data: internalData,
      viewportRef,
      scrollTop,
      visibleCount,
      getItemHeightOrDefault,
      getItemHeightOrDefaultByIndex
    }));
    const handleWrapperResize = (entry) => {
      if (needMeasureViewportHeight.value) {
        setViewportHeight(entry.clientHeight);
      }
    };
    const handleScroll = (e) => {
      if (!viewportRef.value)
        return;
      const {
        scrollTop: rawScrollTop,
        clientHeight,
        scrollHeight
      } = viewportRef.value;
      scrollTop.value = index.getValidScrollTop(rawScrollTop, scrollHeight - clientHeight);
      emit("scroll", e);
    };
    const scrollTo = (options) => {
      rafIdRef.value && raf.caf(rafIdRef.value);
      rafIdRef.value = raf.raf(() => {
        const prepareScrollResult = prepareScrollTo(options);
        if (prepareScrollResult) {
          rangeState.startIndex = prepareScrollResult.startIndex;
          rangeState.endIndex = prepareScrollResult.endIndex;
          vue.nextTick(() => {
            if (!viewportRef.value)
              return;
            const fixScrollResult = fixScrollTo({
              itemIndex: prepareScrollResult.itemIndex,
              relativeTop: prepareScrollResult.relativeTop
            });
            if (fixScrollResult) {
              lockScrollRef.value = true;
              viewportRef.value.scrollTop = fixScrollResult.scrollTop;
              rangeState.itemIndex = fixScrollResult.itemIndex;
              rangeState.itemOffsetPtg = fixScrollResult.itemOffsetPtg;
              rangeState.startIndex = fixScrollResult.startIndex;
              rangeState.endIndex = fixScrollResult.endIndex;
            }
            rafIdRef.value = raf.raf(() => {
              lockScrollRef.value = false;
            });
          });
        }
      });
    };
    vue.watch([itemHeight, visibleCount, scrollTop], () => {
      if (lockScrollRef.value)
        return;
      updateRangeState();
    });
    vue.watch(rangeState, () => {
      vue.nextTick(() => {
        updateScrollOffset();
      });
    });
    return {
      viewportRef,
      visibleData,
      viewportHeight,
      totalHeight,
      startOffset,
      itemHeight,
      isVirtual,
      renderChildren,
      handleWrapperResize,
      handleScroll,
      scrollTo
    };
  }
});
module.exports = _sfc_main;
