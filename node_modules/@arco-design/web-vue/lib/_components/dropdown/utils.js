"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
Object.defineProperty(exports, "__esModule", { value: true });
exports[Symbol.toStringTag] = "Module";
var is = require("../../_utils/is.js");
const isGroupOption = (option) => {
  return is.isObject(option) && "isGroup" in option;
};
const getOptionNodes = ({
  options,
  extraOptions,
  inputValue,
  filterOption,
  showExtraOptions,
  optionInfoMap,
  enabledOptionSet
}) => {
  optionInfoMap.clear();
  enabledOptionSet.clear();
  const getAndSaveOptionInfo = (option, origin) => {
    var _a;
    const index = optionInfoMap.size;
    const optionInfo = is.isObject(option) ? __spreadProps(__spreadValues({}, option), {
      index,
      key: `option-${typeof option.value}-${option.value}`,
      value: option.value,
      label: (_a = option.label) != null ? _a : String(option.value),
      disabled: Boolean(option.disabled),
      origin
    }) : {
      index,
      key: `option-${typeof option}-${option}`,
      value: option,
      label: String(option),
      disabled: false,
      origin
    };
    if (optionInfoMap.get(optionInfo.value)) {
      return void 0;
    }
    optionInfoMap.set(optionInfo.value, optionInfo);
    return optionInfo;
  };
  const isValidOption = (optionInfo) => {
    if (is.isFunction(filterOption)) {
      return !inputValue || filterOption(inputValue, optionInfo);
    }
    if (filterOption) {
      return optionInfo.label.toLowerCase().includes((inputValue != null ? inputValue : "").toLowerCase());
    }
    return true;
  };
  const travelOptions = (options2, origin) => {
    const result = [];
    for (const item of options2) {
      if (isGroupOption(item)) {
        if (is.isArray(item.options) && item.options.length > 0) {
          result.push(__spreadProps(__spreadValues({}, item), {
            key: `group-${item.label}`,
            options: travelOptions(item.options, origin)
          }));
        }
      } else {
        const optionInfo = getAndSaveOptionInfo(item, origin);
        if (optionInfo && isValidOption(optionInfo) && (origin !== "extraOptions" || showExtraOptions)) {
          result.push(__spreadProps(__spreadValues({}, is.isObject(item) ? item : void 0), {
            key: optionInfo.key,
            value: optionInfo.value,
            label: optionInfo.label
          }));
          if (!optionInfo.disabled) {
            enabledOptionSet.add(optionInfo.value);
          }
        }
      }
    }
    return result;
  };
  const nodes = [];
  if (options) {
    nodes.push(...travelOptions(options, "options"));
  }
  if (extraOptions) {
    nodes.push(...travelOptions(extraOptions, "extraOptions"));
  }
  return nodes;
};
exports.getOptionNodes = getOptionNodes;
