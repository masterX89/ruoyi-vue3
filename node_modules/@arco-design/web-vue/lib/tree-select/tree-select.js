"use strict";
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var vue = require("vue");
var useMergeState = require("../_hooks/use-merge-state.js");
var index = require("../trigger/index.js");
var selectView = require("../_components/select-view/select-view.js");
var panel = require("./panel.js");
var globalConfig = require("../_utils/global-config.js");
var useSelectedState = require("./hooks/use-selected-state.js");
var useTreeData = require("../tree/hooks/use-tree-data.js");
var is = require("../_utils/is.js");
var index$1 = require("../empty/index.js");
var useFilterTreeNode = require("./hooks/use-filter-tree-node.js");
var index$2 = require("../spin/index.js");
var pickSubCompSlots = require("../_utils/pick-sub-comp-slots.js");
var context = require("../config-provider/context.js");
var pluginVue_exportHelper = require("../_virtual/plugin-vue_export-helper");
const isEmpty = (val) => {
  return !val || is.isArray(val) && val.length === 0 || is.isEmptyObject(val);
};
const _sfc_main = vue.defineComponent({
  name: "TreeSelect",
  components: {
    Trigger: index,
    SelectView: selectView,
    Panel: panel,
    Empty: index$1,
    Spin: index$2
  },
  inheritAttrs: false,
  props: {
    disabled: {
      type: Boolean
    },
    loading: {
      type: Boolean
    },
    error: {
      type: Boolean
    },
    size: {
      type: String,
      default: () => {
        var _a, _b;
        return (_b = (_a = vue.inject(context.configProviderInjectionKey, void 0)) == null ? void 0 : _a.size) != null ? _b : "medium";
      }
    },
    border: {
      type: Boolean
    },
    allowSearch: {
      type: Boolean
    },
    allowClear: {
      type: Boolean
    },
    placeholder: {
      type: String
    },
    retainInputValue: {
      type: Boolean,
      default: true
    },
    maxTags: {
      type: Number
    },
    multiple: {
      type: Boolean
    },
    defaultValue: {
      type: [String, Number, Array, Object]
    },
    modelValue: {
      type: [String, Number, Array, Object]
    },
    fieldNames: {
      type: Object
    },
    data: {
      type: Array,
      default: () => []
    },
    labelInValue: {
      type: Boolean
    },
    treeCheckable: {
      type: Boolean
    },
    treeCheckStrictly: {
      type: Boolean
    },
    treeCheckedStrategy: {
      type: String,
      default: "all"
    },
    treeProps: {
      type: Object
    },
    triggerProps: {
      type: Object
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean
    },
    dropdownStyle: {
      type: Object
    },
    dropdownClassName: {
      type: [String, Array]
    },
    filterTreeNode: {
      type: Function
    },
    loadMore: {
      type: Function
    },
    disableFilter: {
      type: Boolean
    },
    popupContainer: {
      type: [String, Object]
    },
    onChange: {
      type: [Function, Array]
    },
    onPopupVisibleChange: {
      type: [Function, Array]
    },
    onSearch: {
      type: [Function, Array]
    },
    onClear: { type: [Function, Array] }
  },
  emits: [
    "change",
    "update:modelValue",
    "popup-visible-change",
    "update:popupVisible",
    "search",
    "clear"
  ],
  setup(props, { emit }) {
    const {
      defaultValue,
      modelValue,
      multiple,
      popupVisible,
      defaultPopupVisible,
      treeCheckable,
      treeCheckStrictly,
      data,
      fieldNames,
      labelInValue,
      filterTreeNode,
      disableFilter,
      dropdownStyle,
      treeProps
    } = vue.toRefs(props);
    const prefixCls = globalConfig.getPrefixCls("tree-select");
    const isMultiple = vue.computed(() => multiple.value || treeCheckable.value);
    const { flattenTreeData, key2TreeNode } = useTreeData(vue.reactive({
      treeData: data,
      fieldNames,
      selectable: true,
      checkable: treeCheckable
    }));
    const { selectedKeys, selectedValue, setLocalSelectedKeys } = useSelectedState(vue.reactive({
      defaultValue,
      modelValue,
      key2TreeNode,
      multiple,
      treeCheckable,
      treeCheckStrictly
    }));
    const setSelectedKeys = (newVal) => {
      setLocalSelectedKeys(newVal);
      vue.nextTick(() => {
        let emitValue = (labelInValue.value ? selectedValue.value : newVal) || [];
        emitValue = isMultiple.value ? emitValue : emitValue[0];
        emit("update:modelValue", emitValue);
        emit("change", emitValue);
      });
    };
    const searchValue = vue.ref("");
    const [panelVisible, setLocalPanelVisible] = useMergeState(defaultPopupVisible.value, vue.reactive({
      value: popupVisible
    }));
    const setPanelVisible = (visible) => {
      if (visible !== panelVisible.value) {
        setLocalPanelVisible(visible);
        emit("popup-visible-change", visible);
        emit("update:popupVisible", visible);
      }
      if (!visible) {
        refSelectView.value && refSelectView.value.blur && refSelectView.value.blur();
      }
    };
    const { isEmptyFilterResult, filterTreeNode: computedFilterTreeNode } = useFilterTreeNode(vue.reactive({
      searchValue,
      flattenTreeData,
      filterMethod: filterTreeNode,
      disableFilter,
      fieldNames
    }));
    const isEmptyTreeData = vue.computed(() => isEmpty(key2TreeNode.value));
    const refSelectView = vue.ref();
    const computedDropdownStyle = vue.computed(() => {
      var _a;
      return [
        (dropdownStyle == null ? void 0 : dropdownStyle.value) || {},
        ((_a = treeProps == null ? void 0 : treeProps.value) == null ? void 0 : _a.virtualListProps) ? { "max-height": "unset" } : {}
      ];
    });
    return {
      refSelectView,
      prefixCls,
      selectedValue,
      selectedKeys,
      searchValue,
      panelVisible,
      isEmptyTreeData,
      isEmptyFilterResult,
      computedFilterTreeNode,
      isMultiple,
      computedDropdownStyle,
      onSearchValueChange(newVal) {
        setPanelVisible(true);
        searchValue.value = newVal;
        emit("search", newVal);
      },
      onSelectChange(newVal) {
        setSelectedKeys(newVal);
        searchValue.value = "";
        if (!isMultiple.value) {
          setPanelVisible(false);
        }
      },
      onVisibleChange: setPanelVisible,
      onInnerClear() {
        setSelectedKeys([]);
        emit("clear");
      },
      pickSubCompSlots
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SelectView = vue.resolveComponent("SelectView");
  const _component_Spin = vue.resolveComponent("Spin");
  const _component_Empty = vue.resolveComponent("Empty");
  const _component_Panel = vue.resolveComponent("Panel");
  const _component_Trigger = vue.resolveComponent("Trigger");
  return vue.openBlock(), vue.createBlock(_component_Trigger, vue.mergeProps({
    class: `${_ctx.prefixCls}-trigger`,
    "auto-fit-popup-min-width": "",
    trigger: "click",
    position: "bl",
    "popup-offset": 4,
    "animation-name": "slide-dynamic-origin",
    "prevent-focus": true
  }, _ctx.triggerProps, {
    disabled: _ctx.disabled,
    "popup-visible": _ctx.panelVisible,
    "popup-container": _ctx.popupContainer,
    "auto-fit-transform-origin": "",
    onPopupVisibleChange: _ctx.onVisibleChange
  }), {
    content: vue.withCtx(() => [
      vue.createElementVNode("div", {
        class: vue.normalizeClass([`${_ctx.prefixCls}-popup`, _ctx.dropdownClassName]),
        style: vue.normalizeStyle(_ctx.computedDropdownStyle)
      }, [
        _ctx.loading ? vue.renderSlot(_ctx.$slots, "loader", { key: 0 }, () => [
          vue.createVNode(_component_Spin)
        ]) : _ctx.isEmptyTreeData || _ctx.isEmptyFilterResult ? vue.renderSlot(_ctx.$slots, "empty", { key: 1 }, () => [
          vue.createVNode(_component_Empty)
        ]) : (vue.openBlock(), vue.createBlock(_component_Panel, {
          key: 2,
          "selected-keys": _ctx.selectedKeys,
          checkable: _ctx.treeCheckable,
          "tree-props": __spreadProps(__spreadValues({
            blockNode: true
          }, _ctx.treeProps), {
            data: _ctx.data,
            checkStrictly: _ctx.treeCheckStrictly,
            checkedStrategy: _ctx.treeCheckedStrategy,
            fieldNames: _ctx.fieldNames,
            multiple: _ctx.multiple,
            loadMore: _ctx.loadMore,
            filterTreeNode: _ctx.computedFilterTreeNode,
            size: _ctx.size
          }),
          "tree-slots": _ctx.pickSubCompSlots(_ctx.$slots, "tree"),
          onChange: _ctx.onSelectChange
        }, null, 8, ["selected-keys", "checkable", "tree-props", "tree-slots", "onChange"]))
      ], 6)
    ]),
    default: vue.withCtx(() => [
      vue.renderSlot(_ctx.$slots, "trigger", {}, () => [
        vue.createVNode(_component_SelectView, vue.mergeProps({
          ref: "refSelectView",
          "model-value": _ctx.selectedValue,
          "input-value": _ctx.searchValue,
          "allow-search": _ctx.allowSearch,
          "allow-clear": _ctx.allowClear,
          loading: _ctx.loading,
          size: _ctx.size,
          "max-tags": _ctx.maxTags,
          disabled: _ctx.disabled,
          opened: _ctx.panelVisible,
          error: _ctx.error,
          border: _ctx.border,
          placeholder: _ctx.placeholder,
          multiple: _ctx.isMultiple
        }, _ctx.$attrs, {
          onInputValueChange: _ctx.onSearchValueChange,
          onClear: _ctx.onInnerClear
        }), {
          default: vue.withCtx(() => [
            _ctx.$slots.prefix ? vue.renderSlot(_ctx.$slots, "prefix", { key: 0 }) : vue.createCommentVNode("v-if", true),
            _ctx.$slots.tag ? vue.renderSlot(_ctx.$slots, "tag", { key: 1 }) : vue.createCommentVNode("v-if", true)
          ]),
          _: 3
        }, 16, ["model-value", "input-value", "allow-search", "allow-clear", "loading", "size", "max-tags", "disabled", "opened", "error", "border", "placeholder", "multiple", "onInputValueChange", "onClear"])
      ])
    ]),
    _: 3
  }, 16, ["class", "disabled", "popup-visible", "popup-container", "onPopupVisibleChange"]);
}
var _TreeSelect = /* @__PURE__ */ pluginVue_exportHelper(_sfc_main, [["render", _sfc_render]]);
module.exports = _TreeSelect;
