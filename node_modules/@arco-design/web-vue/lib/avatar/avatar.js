"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var vue = require("vue");
var globalConfig = require("../_utils/global-config.js");
var constants = require("./constants.js");
var pluginVue_exportHelper = require("../_virtual/plugin-vue_export-helper");
const _sfc_main = vue.defineComponent({
  name: "Avatar",
  props: {
    shape: {
      type: String,
      default: "circle",
      validator: (value) => {
        return constants.SHAPES.includes(value);
      }
    },
    size: Number,
    autoFixFontSize: {
      type: Boolean,
      default: true
    },
    triggerIconStyle: {
      type: Object
    },
    triggerType: {
      type: String,
      default: "button",
      validator: (value) => {
        return constants.TRIGGER_TYPES.includes(value);
      }
    }
  },
  emits: [
    "click"
  ],
  setup(props, { slots, emit, attrs }) {
    const prefixCls = globalConfig.getPrefixCls("avatar");
    const { shape, size, autoFixFontSize, triggerType, triggerIconStyle } = vue.toRefs(props);
    const textElementRef = vue.ref();
    const avatarElementRef = vue.ref();
    const hasTriggerIcon = vue.computed(() => Boolean(slots["trigger-icon"]));
    const isImage = useIsImage(slots);
    const wrapperStyle = useWrapperStyle(size.value);
    const computedTriggerIconStyle = useTriggerIconStyle({
      triggerIconStyle: triggerIconStyle == null ? void 0 : triggerIconStyle.value,
      inlineStyle: attrs.style,
      triggerType: triggerType.value
    });
    const autoFixFontSizeHandler = () => {
      const { value: element } = textElementRef;
      if (!element || !autoFixFontSize.value) {
        return;
      }
      vue.nextTick(() => {
        const textWidth = element.clientWidth;
        const avatarWidth = size.value || avatarElementRef.value.offsetWidth;
        const scale = avatarWidth / (textWidth + 8);
        if (avatarWidth && scale < 1) {
          element.style.transform = `scale(${scale}) translateX(-50%)`;
        }
      });
    };
    vue.watch([size, slots.default], autoFixFontSizeHandler);
    vue.onMounted(autoFixFontSizeHandler);
    const cls = vue.computed(() => [
      prefixCls,
      `${prefixCls}-${shape.value}`,
      {
        [`${prefixCls}-with-trigger-icon`]: hasTriggerIcon
      }
    ]);
    const onClick = (e) => {
      emit("click", e);
    };
    return {
      cls,
      onClick,
      wrapperStyle,
      prefixCls,
      textElementRef,
      avatarElementRef,
      isImage,
      hasTriggerIcon,
      computedTriggerIconStyle
    };
  }
});
const useTriggerIconStyle = ({
  triggerType,
  inlineStyle = {},
  triggerIconStyle = {}
}) => {
  let addon = {};
  if (triggerType === "button" && (!triggerIconStyle || triggerIconStyle && !triggerIconStyle.color) && inlineStyle && inlineStyle.backgroundColor) {
    addon = { color: inlineStyle.backgroundColor };
  }
  return __spreadValues(__spreadValues({}, triggerIconStyle), addon);
};
const useWrapperStyle = (size) => {
  return vue.computed(() => size ? {
    width: `${size}px`,
    height: `${size}px`,
    fontSize: `${size / 2}px`
  } : {});
};
const useIsImage = (slots) => {
  return vue.computed(() => {
    const child = slots.default && slots.default()[0];
    return child && ["img", "picture"].includes(child.type);
  });
};
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return vue.openBlock(), vue.createElementBlock("div", {
    ref: "avatarElementRef",
    style: vue.normalizeStyle(_ctx.wrapperStyle),
    class: vue.normalizeClass(_ctx.cls),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, [
    _ctx.isImage ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass(`${_ctx.prefixCls}-image`)
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 2)) : (vue.openBlock(), vue.createElementBlock("span", {
      key: 1,
      ref: "textElementRef",
      class: vue.normalizeClass(`${_ctx.prefixCls}-text`)
    }, [
      vue.renderSlot(_ctx.$slots, "default")
    ], 2)),
    _ctx.hasTriggerIcon ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 2,
      class: vue.normalizeClass(`${_ctx.prefixCls}-trigger-icon-${_ctx.triggerType}`),
      style: vue.normalizeStyle(_ctx.computedTriggerIconStyle)
    }, [
      vue.renderSlot(_ctx.$slots, "trigger-icon")
    ], 6)) : vue.createCommentVNode("v-if", true)
  ], 6);
}
var _Avatar = /* @__PURE__ */ pluginVue_exportHelper(_sfc_main, [["render", _sfc_render]]);
module.exports = _Avatar;
