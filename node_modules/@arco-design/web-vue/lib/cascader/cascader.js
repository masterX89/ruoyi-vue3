"use strict";
var vue = require("vue");
var utils = require("./utils.js");
var index = require("../trigger/index.js");
var selectView = require("../_components/select-view/select-view.js");
var cascaderPanel = require("./cascader-panel.js");
var cascaderSearchPanel = require("./cascader-search-panel.js");
var is = require("../_utils/is.js");
var useSelectedPath = require("./hooks/use-selected-path.js");
var keyboard = require("../_utils/keyboard.js");
var context$1 = require("./context.js");
var context = require("../config-provider/context.js");
var pluginVue_exportHelper = require("../_virtual/plugin-vue_export-helper");
const _sfc_main = vue.defineComponent({
  name: "Cascader",
  components: {
    Trigger: index,
    SelectView: selectView,
    CascaderPanel: cascaderPanel,
    CascaderSearchPanel: cascaderSearchPanel
  },
  inheritAttrs: false,
  props: {
    pathMode: {
      type: Boolean,
      default: false
    },
    multiple: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: [String, Number, Array]
    },
    defaultValue: {
      type: [String, Number, Array],
      default: (props) => props.multiple ? [] : props.mode === "value" ? "" : void 0
    },
    options: {
      type: Array,
      default: () => []
    },
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    size: {
      type: String,
      default: () => {
        var _a, _b;
        return (_b = (_a = vue.inject(context.configProviderInjectionKey, void 0)) == null ? void 0 : _a.size) != null ? _b : "medium";
      }
    },
    allowSearch: {
      type: Boolean,
      default: (props) => Boolean(props.multiple)
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    inputValue: {
      type: String,
      default: void 0
    },
    defaultInputValue: {
      type: String,
      default: ""
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    expandTrigger: {
      type: String,
      default: "click"
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    placeholder: String,
    filterOption: {
      type: Function
    },
    popupContainer: {
      type: [String, Object]
    },
    maxTagCount: {
      type: Number,
      default: 0
    },
    formatLabel: {
      type: Function
    },
    triggerProps: {
      type: Object
    },
    checkStrictly: {
      type: Boolean,
      default: false
    },
    loadMore: {
      type: Function
    },
    loading: {
      type: Boolean,
      default: false
    },
    onChange: {
      type: [Function, Array]
    },
    onInputValueChange: {
      type: [Function, Array]
    },
    onPopupVisibleChange: {
      type: [Function, Array]
    },
    onClear: { type: [Function, Array] },
    onSearch: {
      type: [Function, Array]
    }
  },
  emits: [
    "update:modelValue",
    "change",
    "inputValueChange",
    "clear",
    "search",
    "popupVisibleChange",
    "focus",
    "blur"
  ],
  setup(props, { emit }) {
    const { options, checkStrictly, loadMore } = vue.toRefs(props);
    const _value = vue.ref(props.defaultValue);
    const _inputValue = vue.ref(props.defaultInputValue);
    const _popupVisible = vue.ref(props.defaultPopupVisible);
    const optionInfos = vue.ref([]);
    const totalLevel = vue.ref(1);
    const optionMap = new Map();
    const leafOptionMap = new Map();
    const leafOptionValueMap = new Map();
    const leafOptionSet = new Set();
    const lazyLoadOptions = vue.reactive({});
    const addLazyLoadOptions = (children, key) => {
      lazyLoadOptions[key] = children;
    };
    vue.watch([options, lazyLoadOptions], ([_options, _lazyLoadOptions]) => {
      optionMap.clear();
      leafOptionMap.clear();
      leafOptionValueMap.clear();
      leafOptionSet.clear();
      optionInfos.value = utils.getOptionInfos(props.options, {
        enabledLazyLoad: Boolean(props.loadMore),
        lazyLoadOptions,
        optionMap,
        leafOptionSet,
        leafOptionMap,
        leafOptionValueMap,
        totalLevel,
        checkStrictly
      });
    }, {
      immediate: true
    });
    const computedKeys = vue.computed(() => {
      var _a;
      return utils.getKeysFromValue((_a = props.modelValue) != null ? _a : _value.value, {
        pathMode: props.pathMode,
        leafOptionMap,
        leafOptionValueMap
      });
    });
    const computedInputValue = vue.computed(() => {
      var _a;
      return (_a = props.inputValue) != null ? _a : _inputValue.value;
    });
    const computedPopupVisible = vue.computed(() => {
      var _a;
      return (_a = props.popupVisible) != null ? _a : _popupVisible.value;
    });
    const filteredLeafOptions = vue.computed(() => Array.from(leafOptionSet).filter((item) => {
      var _a, _b, _c, _d;
      return (_d = (_a = props.filterOption) == null ? void 0 : _a.call(props, computedInputValue.value, item)) != null ? _d : (_c = item.label) == null ? void 0 : _c.toLocaleLowerCase().includes((_b = computedInputValue.value) == null ? void 0 : _b.toLocaleLowerCase());
    }));
    const updateValue = (options2) => {
      let value;
      if (!options2) {
        if (!props.pathMode) {
          value = "";
        }
        setSelectedPath();
        setActiveKey();
      } else if (is.isArray(options2)) {
        value = options2.map((item) => {
          if (!props.pathMode) {
            return item.value;
          }
          return item.path.map((item2) => item2.value);
        });
      } else if (!props.pathMode) {
        value = options2.value;
      } else {
        value = options2.path.map((item) => item.value);
      }
      _value.value = value;
      emit("update:modelValue", value);
      emit("change", value);
    };
    const handlePopupVisibleChange = (visible) => {
      if (computedPopupVisible.value !== visible) {
        _popupVisible.value = visible;
        emit("popupVisibleChange", visible);
      }
    };
    const handleRemove = (key) => {
      if (props.multiple) {
        const option = leafOptionMap.get(key);
        if (option) {
          selectMultiple(option, false);
        }
      }
    };
    const selectSingle = (option) => {
      updateValue(option);
      handlePopupVisibleChange(false);
    };
    const selectMultiple = (option, checked) => {
      const leafOptionKeys = props.checkStrictly ? [option.key] : utils.getLeafOptionKeys(option);
      const newKeys = checked ? computedKeys.value.concat(leafOptionKeys.filter((item) => !computedKeys.value.includes(item))) : computedKeys.value.filter((item) => !leafOptionKeys.includes(item));
      updateValue(newKeys.map((key) => leafOptionMap.get(key)));
      handleInputValueChange("", "optionChecked");
    };
    const handleClickOption = (option, checked) => {
      if (props.multiple) {
        selectMultiple(option, checked != null ? checked : true);
      } else {
        selectSingle(option);
      }
    };
    const getOptionLabel = (option) => {
      return option.path.map((item) => item.label).join(" / ");
    };
    const handleInputValueChange = (value, reason) => {
      if (value !== computedInputValue.value) {
        if (reason === "manual" && !computedPopupVisible.value) {
          _popupVisible.value = true;
          emit("popupVisibleChange", true);
        }
        _inputValue.value = value;
        emit("inputValueChange", value);
        if (props.allowSearch) {
          emit("search", value);
        }
      }
    };
    vue.watch(computedPopupVisible, (value) => {
      if (value) {
        if (computedKeys.value.length > 0 && !activeKey.value) {
          const lastKey = computedKeys.value[computedKeys.value.length - 1];
          const option = leafOptionMap.get(lastKey);
          if (option) {
            setSelectedPath(option.key);
            setActiveKey(option.key);
          }
        }
      } else {
        if (computedKeys.value.length === 0) {
          setSelectedPath();
          setActiveKey();
        }
        handleInputValueChange("", "optionListHide");
      }
    });
    const handleClear = (e) => {
      e.stopPropagation();
      if (props.multiple) {
        const newValue = computedKeys.value.reduce((pre, key) => {
          const option = leafOptionMap.get(key);
          if (option == null ? void 0 : option.disabled) {
            pre.push(option);
          }
          return pre;
        }, []);
        updateValue(newValue);
      } else {
        updateValue();
      }
      handleInputValueChange("", "manual");
      emit("clear");
    };
    const showSearchPanel = vue.computed(() => props.allowSearch && computedInputValue.value.length > 0);
    const handleFocus = (e) => {
      emit("focus", e);
    };
    const handleBlur = (e) => {
      emit("blur", e);
    };
    const {
      activeKey,
      activeOption,
      selectedPath,
      displayColumns,
      setActiveKey,
      setSelectedPath,
      getNextActiveNode
    } = useSelectedPath.useSelectedPath(optionInfos, {
      optionMap,
      filteredLeafOptions,
      showSearchPanel
    });
    vue.provide(context$1.cascaderInjectionKey, vue.reactive({
      onClickOption: handleClickOption,
      setActiveKey,
      setSelectedPath,
      loadMore,
      addLazyLoadOptions
    }));
    const handleKeyDown = keyboard.getKeyDownHandler(new Map([
      [
        keyboard.CODE.ENTER,
        (ev) => {
          if (computedPopupVisible.value) {
            if (activeOption.value && (activeOption.value.isLeaf || props.checkStrictly)) {
              handleClickOption(activeOption.value);
            }
          } else {
            handlePopupVisibleChange(true);
          }
        }
      ],
      [
        keyboard.CODE.ESC,
        (ev) => {
          handlePopupVisibleChange(false);
        }
      ],
      [
        keyboard.CODE.ARROW_DOWN,
        (ev) => {
          ev.preventDefault();
          const activeNode = getNextActiveNode("next");
          setActiveKey(activeNode == null ? void 0 : activeNode.key);
        }
      ],
      [
        keyboard.CODE.ARROW_UP,
        (ev) => {
          ev.preventDefault();
          const activeNode = getNextActiveNode("preview");
          setActiveKey(activeNode == null ? void 0 : activeNode.key);
        }
      ],
      [
        keyboard.CODE.ARROW_RIGHT,
        (ev) => {
          var _a, _b;
          ev.preventDefault();
          if ((_a = activeOption.value) == null ? void 0 : _a.children) {
            setSelectedPath(activeOption.value.key);
            setActiveKey((_b = activeOption.value.children[0]) == null ? void 0 : _b.key);
          }
        }
      ],
      [
        keyboard.CODE.ARROW_LEFT,
        (ev) => {
          var _a;
          ev.preventDefault();
          if ((_a = activeOption.value) == null ? void 0 : _a.parent) {
            setSelectedPath(activeOption.value.parent.key);
            setActiveKey(activeOption.value.parent.key);
          }
        }
      ]
    ]));
    const selectViewValue = vue.computed(() => {
      var _a, _b, _c, _d;
      if (props.multiple) {
        const result = [];
        for (const key of computedKeys.value) {
          const option2 = leafOptionMap.get(key);
          if (option2) {
            const value = {
              value: key,
              label: (_b = (_a = props.formatLabel) == null ? void 0 : _a.call(props, option2.path)) != null ? _b : getOptionLabel(option2),
              closable: !option2.disabled,
              tagProps: option2.tagProps
            };
            result.push(value);
          }
        }
        return result;
      }
      const option = leafOptionMap.get(computedKeys.value[0]);
      if (!option) {
        return void 0;
      }
      return {
        value: option.key,
        label: (_d = (_c = props.formatLabel) == null ? void 0 : _c.call(props, option.path)) != null ? _d : getOptionLabel(option),
        closable: !(option == null ? void 0 : option.disabled),
        tagProps: option.tagProps
      };
    });
    return {
      optionInfos,
      computedKeys,
      filteredLeafOptions,
      selectedPath,
      activeKey,
      displayColumns,
      computedInputValue,
      computedPopupVisible,
      handleClear,
      selectViewValue,
      handleInputValueChange,
      showSearchPanel,
      handlePopupVisibleChange,
      handleFocus,
      handleBlur,
      handleRemove,
      handleKeyDown,
      totalLevel
    };
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_select_view = vue.resolveComponent("select-view");
  const _component_cascader_search_panel = vue.resolveComponent("cascader-search-panel");
  const _component_cascader_panel = vue.resolveComponent("cascader-panel");
  const _component_trigger = vue.resolveComponent("trigger");
  return vue.openBlock(), vue.createBlock(_component_trigger, vue.mergeProps(_ctx.triggerProps, {
    trigger: "click",
    "popup-visible": _ctx.computedPopupVisible,
    position: "bl",
    disabled: _ctx.disabled,
    "popup-offset": 4,
    "auto-fit-popup-width": _ctx.showSearchPanel,
    "popup-container": _ctx.popupContainer,
    "prevent-focus": true,
    "click-to-close": !_ctx.allowSearch,
    onPopupVisibleChange: _ctx.handlePopupVisibleChange
  }), {
    content: vue.withCtx(() => [
      _ctx.showSearchPanel ? (vue.openBlock(), vue.createBlock(_component_cascader_search_panel, {
        key: 0,
        options: _ctx.filteredLeafOptions,
        "active-key": _ctx.activeKey,
        "computed-keys": _ctx.computedKeys,
        multiple: _ctx.multiple,
        loading: _ctx.loading
      }, null, 8, ["options", "active-key", "computed-keys", "multiple", "loading"])) : (vue.openBlock(), vue.createBlock(_component_cascader_panel, {
        key: 1,
        "display-columns": _ctx.displayColumns,
        "selected-path": _ctx.selectedPath,
        "active-key": _ctx.activeKey,
        "computed-keys": _ctx.computedKeys,
        multiple: _ctx.multiple,
        "expand-trigger": _ctx.expandTrigger,
        "total-level": _ctx.totalLevel,
        "check-strictly": _ctx.checkStrictly,
        loading: _ctx.loading
      }, null, 8, ["display-columns", "selected-path", "active-key", "computed-keys", "multiple", "expand-trigger", "total-level", "check-strictly", "loading"]))
    ]),
    default: vue.withCtx(() => [
      vue.createVNode(_component_select_view, vue.mergeProps({
        "model-value": _ctx.selectViewValue,
        "input-value": _ctx.computedInputValue,
        disabled: _ctx.disabled,
        error: _ctx.error,
        multiple: _ctx.multiple,
        "allow-clear": _ctx.allowClear,
        "allow-search": _ctx.allowSearch,
        size: _ctx.size,
        opened: _ctx.computedPopupVisible,
        placeholder: _ctx.placeholder,
        loading: _ctx.loading,
        "max-tag-count": _ctx.maxTagCount
      }, _ctx.$attrs, {
        onInputValueChange: _ctx.handleInputValueChange,
        onClear: _ctx.handleClear,
        onFocus: _ctx.handleFocus,
        onBlur: _ctx.handleBlur,
        onRemove: _ctx.handleRemove,
        onKeydown: _ctx.handleKeyDown
      }), null, 16, ["model-value", "input-value", "disabled", "error", "multiple", "allow-clear", "allow-search", "size", "opened", "placeholder", "loading", "max-tag-count", "onInputValueChange", "onClear", "onFocus", "onBlur", "onRemove", "onKeydown"])
    ]),
    _: 1
  }, 16, ["popup-visible", "disabled", "auto-fit-popup-width", "popup-container", "click-to-close", "onPopupVisibleChange"]);
}
var _Cascader = /* @__PURE__ */ pluginVue_exportHelper(_sfc_main, [["render", _sfc_render]]);
module.exports = _Cascader;
