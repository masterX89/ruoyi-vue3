"use strict";
var vue = require("vue");
var globalConfig = require("../_utils/global-config.js");
var context = require("./context.js");
var usePickSlots = require("../_hooks/use-pick-slots.js");
var index = require("./utils/index.js");
var node = require("./node.js");
var is = require("../_utils/is.js");
var useMergeState = require("../_hooks/use-merge-state.js");
var useCheckedState = require("./hooks/use-checked-state.js");
var useTreeData = require("./hooks/use-tree-data.js");
var virtualList = require("../_components/virtual-list/virtual-list.js");
var pluginVue_exportHelper = require("../_virtual/plugin-vue_export-helper");
const _sfc_main = vue.defineComponent({
  name: "Tree",
  components: {
    VirtualList: virtualList,
    TreeNode: node
  },
  props: {
    size: {
      type: String,
      default: "medium"
    },
    blockNode: {
      type: Boolean
    },
    defaultExpandAll: {
      type: Boolean,
      default: true
    },
    multiple: {
      type: Boolean
    },
    checkable: {
      type: Boolean
    },
    selectable: {
      type: Boolean,
      default: true
    },
    checkStrictly: {
      type: Boolean
    },
    checkedStrategy: {
      type: String,
      default: "all"
    },
    defaultSelectedKeys: {
      type: Array
    },
    selectedKeys: {
      type: Array
    },
    defaultCheckedKeys: {
      type: Array
    },
    checkedKeys: {
      type: Array
    },
    defaultExpandedKeys: {
      type: Array
    },
    expandedKeys: {
      type: Array
    },
    data: {
      type: Array,
      default: () => []
    },
    fieldNames: {
      type: Object
    },
    showLine: {
      type: Boolean
    },
    loadMore: {
      type: Function
    },
    draggable: {
      type: Boolean
    },
    allowDrop: {
      type: Function
    },
    filterTreeNode: {
      type: Function
    },
    virtualListProps: {
      type: Object
    },
    defaultExpandSelected: {
      type: Boolean
    },
    defaultExpandChecked: {
      type: Boolean
    },
    autoExpandParent: {
      type: Boolean,
      default: true
    }
  },
  emits: [
    "select",
    "update:selectedKeys",
    "check",
    "update:checkedKeys",
    "expand",
    "update:expandedKeys",
    "dragStart",
    "dragEnd",
    "dragOver",
    "dragLeave",
    "drop"
  ],
  setup(props, { emit, slots }) {
    const {
      data: propTreeData,
      showLine,
      multiple,
      loadMore,
      checkStrictly,
      checkedKeys: propCheckedKeys,
      defaultCheckedKeys,
      selectedKeys: propSelectedKeys,
      defaultSelectedKeys,
      expandedKeys: propExpandedKeys,
      defaultExpandedKeys,
      checkedStrategy,
      selectable,
      checkable,
      blockNode,
      fieldNames,
      size,
      defaultExpandAll,
      filterTreeNode,
      draggable,
      allowDrop,
      defaultExpandSelected,
      defaultExpandChecked,
      autoExpandParent
    } = vue.toRefs(props);
    const prefixCls = globalConfig.getPrefixCls("tree");
    const classNames = vue.computed(() => [
      `${prefixCls}`,
      {
        [`${prefixCls}-checkable`]: checkable.value,
        [`${prefixCls}-show-line`]: showLine.value
      },
      `${prefixCls}-size-${size.value}`
    ]);
    const switcherIcon = usePickSlots(slots, "switcher-icon");
    const loadingIcon = usePickSlots(slots, "loading-icon");
    const dragIcon = usePickSlots(slots, "drag-icon");
    const nodeTitle = usePickSlots(slots, "title");
    const nodeExtra = usePickSlots(slots, "extra");
    const { treeData, flattenTreeData, key2TreeNode } = useTreeData(vue.reactive({
      treeData: propTreeData,
      selectable,
      showLine,
      blockNode,
      checkable,
      fieldNames,
      loadMore,
      draggable
    }));
    const { checkedKeys, indeterminateKeys, setCheckedState } = useCheckedState(vue.reactive({
      defaultCheckedKeys,
      checkedKeys: propCheckedKeys,
      checkStrictly,
      key2TreeNode
    }));
    const [selectedKeys, setSelectedKeys] = useMergeState((defaultSelectedKeys == null ? void 0 : defaultSelectedKeys.value) || [], vue.reactive({
      value: propSelectedKeys
    }));
    const loadingKeys = vue.ref([]);
    const dragNode = vue.ref();
    function getDefaultExpandedKeys() {
      if (defaultExpandedKeys == null ? void 0 : defaultExpandedKeys.value) {
        const expandedKeysSet = new Set([]);
        defaultExpandedKeys.value.forEach((_key) => {
          if (expandedKeysSet.has(_key))
            return;
          const node2 = key2TreeNode.value[_key];
          if (!node2)
            return;
          [
            ...autoExpandParent.value ? node2.pathParentKeys : [],
            _key
          ].forEach((_key2) => expandedKeysSet.add(_key2));
        });
        return [...expandedKeysSet];
      }
      if (defaultExpandAll.value) {
        return flattenTreeData.value.filter((node2) => node2.children && node2.children.length).map((node2) => node2.key);
      }
      if (defaultSelectedKeys.value || defaultExpandChecked.value) {
        const expandedKeysSet = new Set([]);
        const addToExpandKeysSet = (keys) => {
          keys.forEach((key) => {
            const node2 = key2TreeNode.value[key];
            if (!node2)
              return;
            (node2.pathParentKeys || []).forEach((k) => expandedKeysSet.add(k));
          });
        };
        if (defaultExpandSelected.value) {
          addToExpandKeysSet(selectedKeys.value);
        }
        if (defaultExpandChecked.value) {
          addToExpandKeysSet(checkedKeys.value);
        }
        return [...expandedKeysSet];
      }
      return [];
    }
    const [expandedKeys, setExpandKeys] = useMergeState(getDefaultExpandedKeys(), vue.reactive({
      value: propExpandedKeys
    }));
    const currentExpandKeys = vue.ref([]);
    const visibleTreeNodeList = vue.computed(() => {
      const expandedKeysSet = new Set(expandedKeys.value);
      const currentExpandKeysSet = new Set(currentExpandKeys.value);
      return flattenTreeData.value.filter((node2) => {
        var _a;
        const passFilter = !filterTreeNode || !filterTreeNode.value || (filterTreeNode == null ? void 0 : filterTreeNode.value(node2.treeNodeData));
        if (!passFilter)
          return false;
        const isRoot = is.isUndefined(node2.parentKey);
        const isVisibleNode = (_a = node2.pathParentKeys) == null ? void 0 : _a.every((_key) => expandedKeysSet.has(_key) && !currentExpandKeysSet.has(_key));
        return isRoot || isVisibleNode;
      });
    });
    function onCheck(checked, key, e) {
      const node2 = key2TreeNode.value[key];
      if (!node2)
        return;
      const [newCheckedKeys, newIndeterminateKeys] = index.getCheckedStateByCheck({
        node: node2,
        checked,
        checkedKeys: checkedKeys.value,
        indeterminateKeys: indeterminateKeys.value,
        checkStrictly: checkStrictly.value
      });
      setCheckedState(newCheckedKeys, newIndeterminateKeys);
      let publicCheckedKeys = [...newCheckedKeys];
      if (checkedStrategy.value === "parent") {
        publicCheckedKeys = newCheckedKeys.filter((_key) => {
          const item = key2TreeNode.value[_key];
          return !(!is.isUndefined(item.parentKey) && newCheckedKeys.includes(item.parentKey));
        });
      } else if (checkedStrategy.value === "child") {
        publicCheckedKeys = newCheckedKeys.filter((_key) => {
          var _a;
          const item = key2TreeNode.value[_key];
          return !((_a = item.children) == null ? void 0 : _a.length);
        });
      }
      emit("check", publicCheckedKeys, {
        checked,
        node: node2.treeNodeData,
        checkedNodes: publicCheckedKeys.map((v) => {
          var _a;
          return (_a = key2TreeNode.value[v]) == null ? void 0 : _a.treeNodeData;
        }),
        e
      });
      emit("update:checkedKeys", publicCheckedKeys);
    }
    function onSelect(key, e) {
      const node2 = key2TreeNode.value[key];
      if (!node2)
        return;
      let newSelectedKeys;
      let selected;
      if (multiple.value) {
        const selectedKeysSet = new Set(selectedKeys.value);
        selected = !selectedKeysSet.has(key);
        selected ? selectedKeysSet.add(key) : selectedKeysSet.delete(key);
        newSelectedKeys = [...selectedKeysSet];
      } else {
        selected = true;
        newSelectedKeys = [key];
      }
      setSelectedKeys(newSelectedKeys);
      emit("select", newSelectedKeys, {
        selected,
        node: node2.treeNodeData,
        selectedNodes: newSelectedKeys.map((v) => {
          var _a;
          return (_a = key2TreeNode.value[v]) == null ? void 0 : _a.treeNodeData;
        }),
        e
      });
      emit("update:selectedKeys", newSelectedKeys);
    }
    function onExpand(expanded, key, e) {
      if (currentExpandKeys.value.includes(key))
        return;
      const node2 = key2TreeNode.value[key];
      if (!node2)
        return;
      const expandedKeysSet = new Set(expandedKeys.value);
      expanded ? expandedKeysSet.add(key) : expandedKeysSet.delete(key);
      const newExpandedKeys = [...expandedKeysSet];
      setExpandKeys(newExpandedKeys);
      currentExpandKeys.value.push(key);
      emit("expand", newExpandedKeys, {
        expanded,
        node: node2.treeNodeData,
        expandedNodes: newExpandedKeys.map((v) => {
          var _a;
          return (_a = key2TreeNode.value[v]) == null ? void 0 : _a.treeNodeData;
        }),
        e
      });
      emit("update:expandedKeys", newExpandedKeys);
    }
    function onExpandEnd(key) {
      const index2 = currentExpandKeys.value.indexOf(key);
      currentExpandKeys.value.splice(index2, 1);
    }
    const onLoadMore = vue.computed(() => (loadMore == null ? void 0 : loadMore.value) ? async (key) => {
      if (!is.isFunction(loadMore.value))
        return;
      const node2 = key2TreeNode.value[key];
      if (!node2)
        return;
      const { treeNodeData } = node2;
      loadingKeys.value = [...new Set([...loadingKeys.value, key])];
      try {
        await loadMore.value(treeNodeData);
        loadingKeys.value = loadingKeys.value.filter((v) => v !== key);
        onExpand(true, key);
        if (checkedKeys.value.includes(key)) {
          onCheck(true, key);
        }
      } catch (err) {
        loadingKeys.value = loadingKeys.value.filter((v) => v !== key);
        console.error("[tree]load data error: ", err);
      }
    } : void 0);
    const treeContext = vue.reactive({
      switcherIcon,
      loadingIcon,
      dragIcon,
      nodeTitle,
      nodeExtra,
      treeData,
      flattenTreeData,
      key2TreeNode,
      checkedKeys,
      indeterminateKeys,
      selectedKeys,
      expandedKeys,
      loadingKeys,
      currentExpandKeys,
      onLoadMore,
      onCheck,
      onSelect,
      onExpand,
      onExpandEnd,
      allowDrop(key, dropPosition) {
        const nodeData = key2TreeNode.value[key];
        if (nodeData && is.isFunction(allowDrop == null ? void 0 : allowDrop.value)) {
          return !!(allowDrop == null ? void 0 : allowDrop.value({
            dropNode: nodeData,
            dropPosition
          }));
        }
        return true;
      },
      onDragStart(key, e) {
        const nodeData = key2TreeNode.value[key];
        dragNode.value = nodeData;
        if (nodeData) {
          emit("dragStart", e, nodeData);
        }
      },
      onDragEnd(key, e) {
        const nodeData = key2TreeNode.value[key];
        dragNode.value = void 0;
        if (nodeData) {
          emit("dragEnd", e, nodeData);
        }
      },
      onDragOver(key, e) {
        const nodeData = key2TreeNode.value[key];
        if (nodeData) {
          emit("dragOver", e, nodeData);
        }
      },
      onDragLeave(key, e) {
        const nodeData = key2TreeNode.value[key];
        if (nodeData) {
          emit("dragLeave", e, nodeData);
        }
      },
      onDrop(key, dropPosition, e) {
        const nodeData = key2TreeNode.value[key];
        if (dragNode.value && nodeData && !(nodeData.key === dragNode.value.key || nodeData.pathParentKeys.includes(dragNode.value.key || ""))) {
          emit("drop", {
            e,
            dragNode: dragNode.value,
            dropNode: nodeData,
            dropPosition
          });
        }
      }
    });
    vue.provide(context.TreeInjectionKey, treeContext);
    return {
      classNames,
      visibleTreeNodeList,
      treeContext,
      virtualListRef: vue.ref()
    };
  },
  methods: {
    toggleCheck(key, e) {
      const { key2TreeNode, onCheck, checkedKeys } = this.treeContext;
      const checked = !checkedKeys.includes(key);
      const node2 = key2TreeNode[key];
      if (node2 && index.isNodeCheckable(node2)) {
        onCheck(checked, key, e);
      }
    },
    scrollIntoView(options) {
      this.virtualListRef && this.virtualListRef.scrollTo(options);
    }
  }
});
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TreeNode = vue.resolveComponent("TreeNode");
  const _component_VirtualList = vue.resolveComponent("VirtualList");
  return vue.openBlock(), vue.createElementBlock("div", {
    class: vue.normalizeClass(_ctx.classNames)
  }, [
    _ctx.virtualListProps ? (vue.openBlock(), vue.createBlock(_component_VirtualList, vue.mergeProps({
      key: 0,
      ref: "virtualListRef"
    }, _ctx.virtualListProps, { data: _ctx.visibleTreeNodeList }), {
      item: vue.withCtx(({ item: node2 }) => [
        vue.createVNode(_component_TreeNode, vue.mergeProps({
          key: node2.key
        }, node2.treeNodeProps), null, 16)
      ]),
      _: 1
    }, 16, ["data"])) : (vue.openBlock(true), vue.createElementBlock(vue.Fragment, { key: 1 }, vue.renderList(_ctx.visibleTreeNodeList, (node2) => {
      return vue.openBlock(), vue.createBlock(_component_TreeNode, vue.mergeProps({
        key: node2.key
      }, node2.treeNodeProps), null, 16);
    }), 128))
  ], 2);
}
var _Tree = /* @__PURE__ */ pluginVue_exportHelper(_sfc_main, [["render", _sfc_render]]);
module.exports = _Tree;
